<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Webnetes Project</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">The Webnetes Project</a></li><li class="chapter-item expanded affix "><a href="INTRODUCTION.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/develop/index.html"><strong aria-hidden="true">1.1.</strong> Develop</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/develop/c.html"><strong aria-hidden="true">1.1.1.</strong> C</a></li><li class="chapter-item expanded "><a href="getting-started/develop/cpp.html"><strong aria-hidden="true">1.1.2.</strong> C++</a></li><li class="chapter-item expanded "><a href="getting-started/develop/go.html"><strong aria-hidden="true">1.1.3.</strong> Go</a></li><li class="chapter-item expanded "><a href="getting-started/develop/rust.html"><strong aria-hidden="true">1.1.4.</strong> Rust</a></li><li class="chapter-item expanded "><a href="getting-started/develop/zig.html"><strong aria-hidden="true">1.1.5.</strong> Zig</a></li><li class="chapter-item expanded "><a href="getting-started/develop/java.html"><strong aria-hidden="true">1.1.6.</strong> Java</a></li><li class="chapter-item expanded "><a href="getting-started/develop/assemblyscript.html"><strong aria-hidden="true">1.1.7.</strong> AssemblyScript</a></li><li class="chapter-item expanded "><a href="getting-started/develop/more.html"><strong aria-hidden="true">1.1.8.</strong> More</a></li></ol></li><li class="chapter-item expanded "><a href="getting-started/distribute.html"><strong aria-hidden="true">1.2.</strong> Distribute</a></li><li class="chapter-item expanded "><a href="getting-started/operate.html"><strong aria-hidden="true">1.3.</strong> Operate</a></li></ol></li><li class="chapter-item expanded "><a href="architecture/index.html"><strong aria-hidden="true">2.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/compute.html"><strong aria-hidden="true">2.1.</strong> Compute</a></li><li class="chapter-item expanded "><a href="architecture/networking.html"><strong aria-hidden="true">2.2.</strong> Networking</a></li><li class="chapter-item expanded "><a href="architecture/storage.html"><strong aria-hidden="true">2.3.</strong> Storage</a></li><li class="chapter-item expanded "><a href="architecture/management.html"><strong aria-hidden="true">2.4.</strong> Management</a></li></ol></li><li class="chapter-item expanded "><a href="components/index.html"><strong aria-hidden="true">3.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="components/webnetes.html"><strong aria-hidden="true">3.1.</strong> Node (webnetes)</a></li><li class="chapter-item expanded "><a href="components/webnetesctl.html"><strong aria-hidden="true">3.2.</strong> App (webnetesctl)</a></li></ol></li><li class="chapter-item expanded "><a href="bindings/index.html"><strong aria-hidden="true">4.</strong> Bindings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bindings/unisockets.html"><strong aria-hidden="true">4.1.</strong> C/C++ Networking (unisockets)</a></li><li class="chapter-item expanded "><a href="bindings/tinynet.html"><strong aria-hidden="true">4.2.</strong> Go Networking (tinynet)</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">5.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/resources-yaml.html"><strong aria-hidden="true">5.1.</strong> Resources YAML</a></li><li class="chapter-item expanded "><a href="reference/embedding-api.html"><strong aria-hidden="true">5.2.</strong> Embedding API</a></li></ol></li><li class="chapter-item expanded "><a href="CONTRIBUTING.html">Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Webnetes Project</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-webnetes-project" id="the-webnetes-project">The Webnetes Project</a></h1>
<p><a href="https://webnetes.dev/"><img src="./getting-started/img/start.png" alt="webnetesctl start screen" /></a></p>
<p><strong>The Webnetes Project</strong> is an effort to build a peer-to-peer computing platform for the browser and node. It uses <a href="https://en.wikipedia.org/wiki/WebAssembly">WebAssembly</a> for compute, <a href="https://en.wikipedia.org/wiki/WebRTC">WebRTC</a> for networking and <a href="https://en.wikipedia.org/wiki/WebTorrent">WebTorrent</a> for storage.</p>
<p>The Webnetes Project is free and open source, you can find the source code on <a href="https://github.com/alphahorizonio/webnetes">GitHub</a>. Issues and feature requests can be posted on the <a href="https://github.com/alphahorizonio/webnetes/issues">GitHub issue tracker</a>. For more information on contributing, see the <a href="./CONTRIBUTING.html">contributing guide</a>.</p>
<h2><a class="header" href="#next-steps" id="next-steps">Next Steps</a></h2>
<p><strong>Want to learn more about the project?</strong> Continue to the <a href="./INTRODUCTION.html">introduction</a>.</p>
<p><strong>Want to use Webnetes or develop for it?</strong> Follow the <a href="./getting-started">getting started guide</a> or run the app directly:<br></p>
<p><a href="https://webnetes.dev/"><img src="https://github.com/alphahorizonio/webnetesctl/raw/main/img/launch.png" width="240">
</a></p>
<h2><a class="header" href="#license" id="license">License</a></h2>
<p>The Webnetes Project © 2021 Felicitas Pojtinger and contributors</p>
<p>SPDX-License-Identifier: AGPL-3.0</p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Webnetes is a peer-to-peer computing platform for the browser and node. Unlike traditional, server-only container orchestration systems such as <a href="https://kubernetes.io/">Kubernetes</a>, which usually use <a href="https://opencontainers.org/">OCI Containers</a> for compute, <a href="https://github.com/containernetworking/cni">CNI</a> for networking and <a href="https://github.com/container-storage-interface/spec">CSI</a> for storage, Webnetes switches these components out in favor of <a href="https://en.wikipedia.org/wiki/WebAssembly">WebAssembly</a>, <a href="https://en.wikipedia.org/wiki/WebRTC">WebRTC</a> and <a href="https://en.wikipedia.org/wiki/WebTorrent">WebTorrent</a>. By doing so, Webnetes is <strong>universal</strong> — it runs on every system, from the server (using <a href="https://nodejs.org/en/">Node</a>) to the browser.</p>
<p>By using standardized web APIs and polyfilling APIs that would normally only be found on the server (such as <a href="https://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley sockets</a>) to work everywhere, Webnetes is able to bridge the gap between devices. It even runs on iOS (using Safari) and other heavily restricted proprietary mobile operating systems, without requiring any installation. Joining a cluster becomes as easy as scanning a QR code or clicking a link; no need for proprietary app distribution mechanisms like the App Store or the Play Store. Many workloads can thus also be moved from the server to the client, removing the dependency on expensive servers or proprietary cloud systems such as AWS or GCP.</p>
<p>Due to recent advancements to the web platform, apps are no longer limited to only using JavaScript — Webnetes uses WebAssembly, which means that many languages, including C, C++, Go, Rust and Java, are supported. You also aren't limited to apps without native capabilities either; almost all web APIs are available, including <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Bluetooth_API">Web Bluetooth</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/USB">Web USB</a>, <a href="https://www.w3.org/TR/webmidi/">Web MIDI</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API">File System Access</a> and many more. In most cases, getting an app to run in Webnetes simply means to recompile to WebAssembly. Even software that depends on lower-level networking (such as TCP client/server systems) or terminals runs effortlessly. Thanks to the power of WebRTC, typical networking barriers in building distributed apps are also removed; Webnetes creates global peer-to-peer overlay networks, removing the need for complex and expensive VPN or tunneling setups.</p>
<p>Ready to learn how to use Webnetes? Continue to the <a href="./getting-started">getting started guide</a>!</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>In this guide, we'll do the following:</p>
<ol>
<li><a href="getting-started/./develop">Develop</a> an app which runs on Webnetes</li>
<li><a href="getting-started/./distribute.html">Distribute</a> the app to Webnetes</li>
<li><a href="getting-started/./operate.html">Operate</a> the running app</li>
</ol>
<p>After you've finished this guide, you'll have a good understanding of how to use Webnetes.</p>
<blockquote>
<p>Need help? Join <a href="https://matrix.to/#/#webnetes-contributors:matrix.org?via=matrix.org">Webnetes Users on Matrix</a> and we'll help you.</p>
</blockquote>
<h1><a class="header" href="#develop" id="develop">Develop</a></h1>
<p>Getting started developing for Webnetes is simple and not much harder than native development; migrating existing apps is also possible. In most cases, the only difference from a Webnetes-enabled project to a native-only project is the additional Webnetes target.</p>
<p>We have guides for a few popular, officially supported languages like Go and Rust to get you started quickly. If your language doesn't have such a guide, you can probably still get it to work; see <a href="getting-started/develop/./more.html">More</a>.</p>
<h1><a class="header" href="#c" id="c">C</a></h1>
<h2><a class="header" href="#table-of-contents" id="table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="getting-started/develop/c.html#language-support-status">Language Support Status</a></li>
<li><a href="getting-started/develop/c.html#hello-world">Hello, world!</a>
<ul>
<li><a href="getting-started/develop/c.html#source-code">Source Code</a></li>
<li><a href="getting-started/develop/c.html#cmake-configuration">CMake Configuration</a></li>
<li><a href="getting-started/develop/c.html#make-configuration">Make Configuration</a></li>
<li><a href="getting-started/develop/c.html#next-steps">Next Steps</a></li>
</ul>
</li>
<li><a href="getting-started/develop/c.html#tcp-echo-server">TCP Echo Server</a>
<ul>
<li><a href="getting-started/develop/c.html#source-code-1">Source Code</a></li>
<li><a href="getting-started/develop/c.html#cmake-configuration-1">CMake Configuration</a></li>
<li><a href="getting-started/develop/c.html#make-configuration-1">Make Configuration</a></li>
<li><a href="getting-started/develop/c.html#next-steps-1">Next Steps</a></li>
</ul>
</li>
<li><a href="getting-started/develop/c.html#tcp-echo-client">TCP Echo Client</a>
<ul>
<li><a href="getting-started/develop/c.html#source-code-2">Source Code</a></li>
<li><a href="getting-started/develop/c.html#cmake-configuration-2">CMake Configuration</a></li>
<li><a href="getting-started/develop/c.html#make-configuration-2">Make Configuration</a></li>
<li><a href="getting-started/develop/c.html#next-steps-2">Next Steps</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#language-support-status" id="language-support-status">Language Support Status</a></h2>
<table><thead><tr><th>Native</th><th>WebAssembly</th><th>Networking</th><th>Concurrency</th></tr></thead><tbody>
<tr><td>✅</td><td>✅</td><td>✅</td><td>❌<sup class="footnote-reference"><a href="#1">1</a></sup></td></tr>
</tbody></table>
<h2><a class="header" href="#hello-world" id="hello-world">Hello, world!</a></h2>
<p>Let's start by writing a hello world app in C with native and WebAssembly targets. The full source code of this example is available on <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples/c_hello_world">GitHub</a>.</p>
<h3><a class="header" href="#source-code" id="source-code">Source Code</a></h3>
<p>Create <code>main.c</code> with the following content:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
  printf(&quot;Hello, world!\n&quot;);

  return 0;
}
</code></pre>
<p>It prints <code>Hello, world!</code> to standard output.</p>
<h3><a class="header" href="#cmake-configuration" id="cmake-configuration">CMake Configuration</a></h3>
<p>Create <code>CMakeLists.txt</code> with the following content:</p>
<pre><code class="language-CMake">cmake_minimum_required(VERSION 3.13.4)

# WASI Config
if(WASI)
	set(WASI_SDK_PREFIX &quot;/opt/wasi-sdk-12.0&quot;)
	set(CMAKE_SYSROOT &quot;${WASI_SDK_PREFIX}/share/wasi-sysroot&quot;)
	set(CMAKE_TOOLCHAIN_FILE &quot;${WASI_SDK_PREFIX}/share/cmake/wasi-sdk.cmake&quot;)
endif()

# Project
project(hello_world)
add_executable(hello_world &quot;main.c&quot;)

# WASI Config
if(WASI)
	set(CMAKE_EXE_LINKER_FLAGS &quot;-Wl,--allow-undefined&quot;)
	set(CMAKE_EXECUTABLE_SUFFIX &quot;.wasm&quot;)

	add_custom_command(TARGET hello_world
		POST_BUILD
		COMMAND sh -c &quot;wasm-opt --asyncify -O $&lt;TARGET_FILE:hello_world&gt; -o $&lt;TARGET_FILE:hello_world&gt;&quot;
		VERBATIM
	)
endif()
</code></pre>
<p>It allows compilation of both the native &amp; the WebAssembly target.</p>
<h3><a class="header" href="#make-configuration" id="make-configuration">Make Configuration</a></h3>
<p>Create a <code>Makefile</code> with the following content:</p>
<pre><code class="language-Makefile">all: native wasm

native:
	@docker run -v ${PWD}:/src:z silkeh/clang sh -c 'cd /src &amp;&amp; mkdir -p build/native &amp;&amp; cd build/native &amp;&amp; cmake ../.. &amp;&amp; make'

wasm:
	@docker run -v ${PWD}:/src:z alphahorizonio/wasi-sdk sh -c 'cd /src &amp;&amp; mkdir -p build/wasm &amp;&amp; cd build/wasm &amp;&amp; cmake -DWASI=true ../.. &amp;&amp; make'

clean:
	@rm -rf build

seed: wasm
	@docker run -it -v ${PWD}/build:/build:z --entrypoint=/bin/sh schaurian/webtorrent-hybrid -c &quot;/usr/local/bin/webtorrent-hybrid seed /build/wasm/*.wasm&quot;
</code></pre>
<p>It provides five targets:</p>
<ul>
<li><code>make</code> builds both the native &amp; the WebAssembly target</li>
<li><code>make native</code> builds only the native target</li>
<li><code>make wasm</code> builds only the WebAssembly target</li>
<li><code>make clean</code> removes the built targets</li>
<li><code>make seed</code> seeds the WebAssembly target, which will come in handy later.</li>
</ul>
<p>All of them use Docker, so there is no need to install any dependencies on the host.</p>
<h3><a class="header" href="#next-steps-1" id="next-steps-1">Next Steps</a></h3>
<p>Build the native target:</p>
<pre><code class="language-shell">$ make native
</code></pre>
<p>Run the native target:</p>
<pre><code class="language-shell">$ ./build/native/hello_world
Hello, world!
</code></pre>
<p>The native target works! Now continue to <a href="getting-started/develop/../distribute.html">Distribute</a> to learn how to run the WebAssembly target.</p>
<h2><a class="header" href="#tcp-echo-server" id="tcp-echo-server">TCP Echo Server</a></h2>
<p>Webnetes has support for networking. Let's create a TCP echo server in C with native and WebAssembly targets. The full source code of this example is available on <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples/c_echo_server">GitHub</a>.</p>
<h3><a class="header" href="#source-code-1" id="source-code-1">Source Code</a></h3>
<p>Create <code>main.c</code> with the following content:</p>
<details>
	<summary>C Source</summary>
<pre><code class="language-c">#include &quot;unisockets.h&quot;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;strings.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#define BACKLOG 5

#define RECEIVED_MESSAGE_BUFFER_LENGTH 1024
#define SENT_MESSAGE_PREFIX &quot;You've sent: &quot;
#define SENT_MESSAGE_BUFFER_LENGTH                                             \
  RECEIVED_MESSAGE_BUFFER_LENGTH + sizeof(SENT_MESSAGE_PREFIX)

int main(int argc, char *argv[]) {
  // Flags parsing
  char *listen_host = &quot;127.0.0.1&quot;;
  int listen_port = 1234;

  int opt;
  while ((opt = getopt(argc, argv, &quot;l:p:&quot;)) != -1) {
    switch (opt) {
    case 'l':
      listen_host = optarg;

      optind--;

      break;

    case 'p':
      listen_port = atoi(optarg);

      break;

    default:
      fprintf(stderr, &quot;Usage: %s -l HOST -p PORT\n&quot;, argv[0]);

      exit(EXIT_FAILURE);
    }
  }

  // Variables
  int server_sock;
  int client_sock;

  struct sockaddr_in server_address;
  struct sockaddr_in client_address;

  socklen_t server_socket_length = sizeof(struct sockaddr_in);

  size_t received_message_length;
  char received_message[RECEIVED_MESSAGE_BUFFER_LENGTH];
  ssize_t sent_message_length;
  char sent_message[SENT_MESSAGE_BUFFER_LENGTH];
  char client_address_readable[sizeof(client_address.sin_addr) +
                               client_address.sin_port + 1];
  char client_address_human_readable[INET_ADDRSTRLEN];

  // Logging
  char server_address_readable[sizeof(listen_host) + sizeof(listen_port) + 1];
  sprintf(server_address_readable, &quot;%s:%d&quot;, listen_host, listen_port);

  memset(&amp;server_address, 0, sizeof(server_address));
  memset(&amp;client_address, 0, sizeof(client_address));

  // Create address
  server_address.sin_family = AF_INET;
  server_address.sin_port = htons(listen_port);
  if (inet_pton(AF_INET, listen_host, &amp;server_address.sin_addr) == -1) {
    perror(&quot;[ERROR] Could not parse IP address:&quot;);

    exit(EXIT_FAILURE);
  }

  // Create socket
  if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
    perror(&quot;[ERROR] Could not create socket:&quot;);

    printf(&quot;[ERROR] Could not create socket %s\n&quot;, server_address_readable);

    exit(EXIT_FAILURE);
  }

  // Bind
  if ((bind(server_sock, (struct sockaddr *)&amp;server_address,
            server_socket_length)) == -1) {
    perror(&quot;[ERROR] Could not bind to socket:&quot;);

    printf(&quot;[ERROR] Could not bind to socket %s\n&quot;, server_address_readable);

    exit(EXIT_FAILURE);
  }

  // Listen
  if ((listen(server_sock, BACKLOG)) == -1) {
    perror(&quot;[ERROR] Could not listen on socket:&quot;);

    printf(&quot;[ERROR] Could not listen on socket %s\n&quot;, server_address_readable);

    exit(EXIT_FAILURE);
  }

  printf(&quot;[INFO] Listening on %s\n&quot;, server_address_readable);

  // Accept loop
  while (1) {
    printf(&quot;[DEBUG] Accepting on %s\n&quot;, server_address_readable);

    // Accept
    if ((client_sock = accept(server_sock, (struct sockaddr *)&amp;client_address,
                              &amp;server_socket_length)) == -1) {
      perror(&quot;[ERROR] Could not accept, continuing:&quot;);

      continue;
    }

    if (inet_pton(AF_INET, listen_host, &amp;server_address.sin_addr) == -1) {
      perror(&quot;[ERROR] Could not parse IP address:&quot;);

      continue;
    }

    inet_ntop(AF_INET, &amp;client_address.sin_addr, client_address_human_readable,
              sizeof(client_address_human_readable));

    sprintf(client_address_readable, &quot;%s:%d&quot;, client_address_human_readable,
            client_address.sin_port);

    printf(&quot;[INFO] Accepted client %s\n&quot;, client_address_readable);

    // Receive loop
    received_message_length = 1;
    while (received_message_length) {
      memset(&amp;received_message, 0, RECEIVED_MESSAGE_BUFFER_LENGTH);
      memset(&amp;sent_message, 0, SENT_MESSAGE_BUFFER_LENGTH);

      printf(&quot;[DEBUG] Waiting for client %s to send\n&quot;,
             client_address_readable);

      // Receive
      received_message_length = recv(client_sock, &amp;received_message,
                                     RECEIVED_MESSAGE_BUFFER_LENGTH, 0);
      if (received_message_length == -1) {
        perror(&quot;[ERROR] Could not receive from client:&quot;);

        printf(&quot;[ERROR] Could not receive from client %s, dropping message\n&quot;,
               client_address_readable);

        break;
      }

      if (received_message_length == 0) {
        break;
      }

      printf(&quot;[DEBUG] Received %zd bytes from %s\n&quot;, received_message_length,
             client_address_readable);

      // Process
      sprintf((char *)&amp;sent_message, &quot;%s%s&quot;, SENT_MESSAGE_PREFIX,
              received_message);
      sent_message[SENT_MESSAGE_BUFFER_LENGTH - 1] = '\0';

      // Send
      sent_message_length =
          send(client_sock, sent_message, SENT_MESSAGE_BUFFER_LENGTH, 0);
      if (sent_message_length == -1) {
        perror(&quot;[ERROR] Could not send to client:&quot;);

        printf(&quot;[ERROR] Could not send to client %s, dropping message\n&quot;,
               client_address_readable);

        break;
      }

      printf(&quot;[DEBUG] Sent %zd bytes to %s\n&quot;, sent_message_length,
             client_address_readable);
    }

    printf(&quot;[INFO] Client %s disconnected\n&quot;, client_address_readable);

    // Shutdown
    if ((shutdown(client_sock, SHUT_RDWR)) == -1) {
      perror(&quot;[ERROR] Could not shutdown socket:&quot;);

      printf(&quot;[ERROR] Could not shutdown socket %s, stopping\n&quot;,
             client_address_readable);

      break;
    };
  }

  return 0;
}
</code></pre>
</details>
<p>It is a very simple TCP server that listens to messages, prefixes them with <code>You've sent: </code> and sends them back to the sender.</p>
<p>Now, copy and paste the <a href="https://github.com/alphahorizonio/webnetes/blob/main/examples/c_echo_server/unisockets.h">unisockets.h</a> header in the same directory as <code>main.c</code>, which allows networking to function.</p>
<h3><a class="header" href="#cmake-configuration-1" id="cmake-configuration-1">CMake Configuration</a></h3>
<p>Create <code>CMakeLists.txt</code> with the following content:</p>
<pre><code class="language-CMake">cmake_minimum_required(VERSION 3.13.4)

# WASI Config
if(WASI)
	set(WASI_SDK_PREFIX &quot;/opt/wasi-sdk-12.0&quot;)
	set(CMAKE_SYSROOT &quot;${WASI_SDK_PREFIX}/share/wasi-sysroot&quot;)
	set(CMAKE_TOOLCHAIN_FILE &quot;${WASI_SDK_PREFIX}/share/cmake/wasi-sdk.cmake&quot;)
endif()

# Project
project(echo_server)
add_executable(echo_server &quot;main.c&quot;)

# WASI Config
if(WASI)
	set(CMAKE_C_FLAGS &quot;-DUNISOCKETS_WITH_ALIAS&quot;)
	set(CMAKE_EXE_LINKER_FLAGS &quot;-Wl,--allow-undefined&quot;)
	set(CMAKE_EXECUTABLE_SUFFIX &quot;.wasm&quot;)

	add_custom_command(TARGET echo_server
		POST_BUILD
		COMMAND sh -c &quot;wasm-opt --asyncify -O $&lt;TARGET_FILE:echo_server&gt; -o $&lt;TARGET_FILE:echo_server&gt;&quot;
		VERBATIM
	)
endif()
</code></pre>
<p>It allows compilation of both the native &amp; the WebAssembly target. Note <code>-DUNISOCKETS_WITH_ALIAS</code>, which allows networking to function.</p>
<h3><a class="header" href="#make-configuration-1" id="make-configuration-1">Make Configuration</a></h3>
<p>See <a href="getting-started/develop/c.html#make-configuration">Hello, world! Make Configuration</a>.</p>
<h3><a class="header" href="#next-steps-2" id="next-steps-2">Next Steps</a></h3>
<p>Build the native target:</p>
<pre><code class="language-shell">$ make native
</code></pre>
<p>Run the native target:</p>
<pre><code class="language-shell">$ ./build/native/echo_server
[INFO] Listening on 127.0.0.1:1234
[DEBUG] Accepting on 127.0.0.1:1234
</code></pre>
<p>In a second terminal, connect to the server:</p>
<pre><code class="language-shell">$ nc localhost 1234
</code></pre>
<p>The server should now display the following:</p>
<pre><code class="language-shell">[INFO] Accepted client 127.0.0.1:39644
[DEBUG] Waiting for client 127.0.0.1:39644 to send
</code></pre>
<p>If you type something into the second terminal and press <kbd>Enter</kbd>, the server should echo it as follows:</p>
<pre><code class="language-shell">Hello, reader!
You've sent: Hello, reader!
</code></pre>
<p>The native target works! Now continue to <a href="getting-started/develop/../distribute.html">Distribute</a> to learn how to run the WebAssembly target.</p>
<h2><a class="header" href="#tcp-echo-client" id="tcp-echo-client">TCP Echo Client</a></h2>
<p>Now that we've got a TCP echo server, let's create a TCP echo client in C with native and WebAssembly targets. The full source code of this example is available on <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples/c_echo_client">GitHub</a>.</p>
<h3><a class="header" href="#source-code-2" id="source-code-2">Source Code</a></h3>
<p>Create <code>main.c</code> with the following content:</p>
<details>
	<summary>C Source</summary>
<pre><code class="language-c">#include &quot;unisockets.h&quot;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

#define RECONNECT_TIMEOUT 2

#define SENT_MESSAGE_BUFFER_LENGTH 1024
#define RECEIVED_MESSAGE_PREFIX &quot;You've sent: &quot;
#define RECEIVED_MESSAGE_BUFFER_LENGTH                                         \
  SENT_MESSAGE_BUFFER_LENGTH + sizeof(RECEIVED_MESSAGE_PREFIX)

int main(int argc, char *argv[]) {
  // Flags parsing
  char *connect_host = &quot;127.0.0.1&quot;;
  int connect_port = 1234;

  int opt;
  while ((opt = getopt(argc, argv, &quot;c:p:&quot;)) != -1) {
    switch (opt) {
    case 'c':
      connect_host = optarg;

      optind--;

      break;

    case 'p':
      connect_port = atoi(optarg);

      break;

    default:
      fprintf(stderr, &quot;Usage: %s -c HOST -p PORT\n&quot;, argv[0]);

      exit(EXIT_FAILURE);
    }
  }

  // Variables
  int server_sock;
  struct sockaddr_in server_host;

  ssize_t sent_message_length;
  char read_message[SENT_MESSAGE_BUFFER_LENGTH];
  size_t received_message_length;
  char received_message[RECEIVED_MESSAGE_BUFFER_LENGTH];

  socklen_t server_host_length = sizeof(struct sockaddr_in);

  memset(&amp;server_host, 0, sizeof(server_host));

  // Logging
  char server_address_readable[sizeof(connect_host) + sizeof(connect_port) + 1];
  sprintf(server_address_readable, &quot;%s:%d&quot;, connect_host, connect_port);

  // Create address
  server_host.sin_family = AF_INET;
  server_host.sin_port = htons(connect_port);
  if (inet_pton(AF_INET, connect_host, &amp;server_host.sin_addr) == -1) {
    perror(&quot;[ERROR] Could not parse IP address:&quot;);

    exit(EXIT_FAILURE);
  }

  // Create socket
  if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
    perror(&quot;[ERROR] Could not create socket:&quot;);

    printf(&quot;[ERROR] Could not create socket %s\n&quot;, server_address_readable);

    exit(EXIT_FAILURE);
  }

  // Connect loop
  while (1) {
    printf(&quot;[INFO] Connecting to server %s\n&quot;, server_address_readable);

    // Connect
    if ((connect(server_sock, (struct sockaddr *)&amp;server_host,
                 server_host_length)) == -1) {
      perror(&quot;[ERROR] Could not connect to server:&quot;);

      printf(&quot;[ERROR] Could not connect to server %s, retrying in %ds\n&quot;,
             server_address_readable, RECONNECT_TIMEOUT);

      sleep(RECONNECT_TIMEOUT);

      continue;
    }

    printf(&quot;[INFO] Connected to server %s\n&quot;, server_address_readable);

    // Read loop
    while (1) {
      memset(&amp;received_message, 0, RECEIVED_MESSAGE_BUFFER_LENGTH);
      memset(&amp;read_message, 0, SENT_MESSAGE_BUFFER_LENGTH);

      printf(&quot;[DEBUG] Waiting for user input\n&quot;);

      // Read
      fgets(read_message, SENT_MESSAGE_BUFFER_LENGTH, stdin);

      // Send
      sent_message_length =
          send(server_sock, read_message, strlen(read_message), 0);
      if (sent_message_length == -1) {
        perror(&quot;[ERROR] Could not send to server:&quot;);

        printf(&quot;[ERROR] Could not send to server %s, dropping message\n&quot;,
               server_address_readable);

        break;
      }

      printf(&quot;[DEBUG] Sent %zd bytes to %s\n&quot;, sent_message_length,
             server_address_readable);

      printf(&quot;[DEBUG] Waiting for server %s to send\n&quot;,
             server_address_readable);

      // Receive
      received_message_length = recv(server_sock, &amp;received_message,
                                     RECEIVED_MESSAGE_BUFFER_LENGTH, 0);
      if (received_message_length == -1) {
        perror(&quot;[ERROR] Could not receive from server:&quot;);

        printf(&quot;[ERROR] Could not receive from server %s, dropping message\n&quot;,
               server_address_readable);

        break;
      }

      if (received_message_length == 0) {
        break;
      }

      printf(&quot;[DEBUG] Received %zd bytes from %s\n&quot;, received_message_length,
             server_address_readable);

      // Print
      printf(&quot;%s&quot;, received_message);
    }

    printf(&quot;[INFO] Disconnected from server %s\n&quot;, server_address_readable);

    // Shutdown
    if ((shutdown(server_sock, SHUT_RDWR)) == -1) {
      perror(&quot;[ERROR] Could not shutdown socket:&quot;);

      printf(&quot;[ERROR] Could not shutdown socket %s, stopping\n&quot;,
             server_address_readable);

      break;
    };
  }

  return 0;
}
</code></pre>
</details>
<p>It is a very simple TCP client that reads a message from standard input, sends it to the server, waits for a reply, and prints it to standard out.</p>
<p>Now, copy and paste the <a href="https://github.com/alphahorizonio/webnetes/blob/main/examples/c_echo_client/unisockets.h">unisockets.h</a> header in the same directory as <code>main.c</code>, which allows networking to function.</p>
<h3><a class="header" href="#cmake-configuration-2" id="cmake-configuration-2">CMake Configuration</a></h3>
<p>Create <code>CMakeLists.txt</code> with the following content:</p>
<pre><code class="language-CMake">cmake_minimum_required(VERSION 3.13.4)

# WASI Config
if(WASI)
	set(WASI_SDK_PREFIX &quot;/opt/wasi-sdk-12.0&quot;)
	set(CMAKE_SYSROOT &quot;${WASI_SDK_PREFIX}/share/wasi-sysroot&quot;)
	set(CMAKE_TOOLCHAIN_FILE &quot;${WASI_SDK_PREFIX}/share/cmake/wasi-sdk.cmake&quot;)
endif()

# Project
project(echo_client)
add_executable(echo_client &quot;main.c&quot;)

# WASI Config
if(WASI)
	set(CMAKE_C_FLAGS &quot;-DUNISOCKETS_WITH_ALIAS&quot;)
	set(CMAKE_EXE_LINKER_FLAGS &quot;-Wl,--allow-undefined&quot;)
	set(CMAKE_EXECUTABLE_SUFFIX &quot;.wasm&quot;)

	add_custom_command(TARGET echo_client
		POST_BUILD
		COMMAND sh -c &quot;wasm-opt --asyncify -O $&lt;TARGET_FILE:echo_client&gt; -o $&lt;TARGET_FILE:echo_client&gt;&quot;
		VERBATIM
	)
endif()
</code></pre>
<p>It allows compilation of both the native &amp; the WebAssembly target. Note <code>-DUNISOCKETS_WITH_ALIAS</code>, which allows networking to function.</p>
<h3><a class="header" href="#make-configuration-2" id="make-configuration-2">Make Configuration</a></h3>
<p>See <a href="getting-started/develop/c.html#make-configuration">Hello, world! Make Configuration</a>.</p>
<h3><a class="header" href="#next-steps-3" id="next-steps-3">Next Steps</a></h3>
<p>First, <a href="getting-started/develop/c.html#next-steps-1">build and run the TCP echo server</a>.</p>
<p>In a second terminal, build the native target:</p>
<pre><code class="language-shell">$ make native
</code></pre>
<p>Run the native target:</p>
<pre><code class="language-shell">$ ./build/native/echo_client
[INFO] Connecting to server 127.0.0.1:1234
[INFO] Connected to server 127.0.0.1:1234
[DEBUG] Waiting for user input
</code></pre>
<p>The server should now display the following:</p>
<pre><code class="language-shell">[INFO] Accepted client 127.0.0.1:39644
[DEBUG] Waiting for client 127.0.0.1:39644 to send
</code></pre>
<p>If you type something into the terminal and press <kbd>Enter</kbd>, the server should echo it as follows:</p>
<pre><code class="language-shell">Hello, dear reader!
[DEBUG] Sent 20 bytes to 127.0.0.1:1234
[DEBUG] Waiting for server 127.0.0.1:1234 to send
[DEBUG] Received 1038 bytes from 127.0.0.1:1234
You've sent: Hello, dear reader!
[DEBUG] Waiting for user input
</code></pre>
<p>The native target works! Now continue to <a href="getting-started/develop/../distribute.html">Distribute</a> to learn how to run the WebAssembly target.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/WebAssembly/threads">WebAssembly threads</a> are not yet implemented.</p>
</div>
<h1><a class="header" href="#c-1" id="c-1">C++</a></h1>
<h2><a class="header" href="#table-of-contents-1" id="table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="getting-started/develop/cpp.html#language-support-status">Language Support Status</a></li>
<li><a href="getting-started/develop/cpp.html#hello-world">Hello, world!</a>
<ul>
<li><a href="getting-started/develop/cpp.html#source-code">Source Code</a></li>
<li><a href="getting-started/develop/cpp.html#cmake-configuration">CMake Configuration</a></li>
<li><a href="getting-started/develop/cpp.html#make-configuration">Make Configuration</a></li>
<li><a href="getting-started/develop/cpp.html#next-steps">Next Steps</a></li>
</ul>
</li>
<li><a href="getting-started/develop/cpp.html#tcp-echo-server">TCP Echo Server</a>
<ul>
<li><a href="getting-started/develop/cpp.html#source-code-1">Source Code</a></li>
<li><a href="getting-started/develop/cpp.html#cmake-configuration-1">CMake Configuration</a></li>
<li><a href="getting-started/develop/cpp.html#make-configuration-1">Make Configuration</a></li>
<li><a href="getting-started/develop/cpp.html#next-steps-1">Next Steps</a></li>
</ul>
</li>
<li><a href="getting-started/develop/cpp.html#tcp-echo-client">TCP Echo Client</a>
<ul>
<li><a href="getting-started/develop/cpp.html#source-code-2">Source Code</a></li>
<li><a href="getting-started/develop/cpp.html#cmake-configuration-2">CMake Configuration</a></li>
<li><a href="getting-started/develop/cpp.html#make-configuration-2">Make Configuration</a></li>
<li><a href="getting-started/develop/cpp.html#next-steps-2">Next Steps</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#language-support-status-1" id="language-support-status-1">Language Support Status</a></h2>
<table><thead><tr><th>Native</th><th>WebAssembly</th><th>Networking</th><th>Concurrency</th></tr></thead><tbody>
<tr><td>✅</td><td>✅</td><td>✅</td><td>❌<sup class="footnote-reference"><a href="#1">1</a></sup></td></tr>
</tbody></table>
<h2><a class="header" href="#hello-world-1" id="hello-world-1">Hello, world!</a></h2>
<p>Let's start by writing a hello world app in C++ with native and WebAssembly targets. For C++, the process is pretty much the same as for <a href="getting-started/develop/./c.html">C</a>. The full source code of this example is available on <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples/cpp_hello_world">GitHub</a>.</p>
<h3><a class="header" href="#source-code-3" id="source-code-3">Source Code</a></h3>
<p>Create <code>main.cpp</code> with the following content:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;

  return 0;
}
</code></pre>
<p>It prints <code>Hello, world!</code> to standard output.</p>
<h3><a class="header" href="#cmake-configuration-3" id="cmake-configuration-3">CMake Configuration</a></h3>
<p>Create <code>CMakeLists.txt</code> with the following content:</p>
<pre><code class="language-CMake">cmake_minimum_required(VERSION 3.13.4)

# WASI Config
if(WASI)
	set(WASI_SDK_PREFIX &quot;/opt/wasi-sdk-12.0&quot;)
	set(CMAKE_SYSROOT &quot;${WASI_SDK_PREFIX}/share/wasi-sysroot&quot;)
	set(CMAKE_TOOLCHAIN_FILE &quot;${WASI_SDK_PREFIX}/share/cmake/wasi-sdk.cmake&quot;)
endif()

# Project
project(hello_world)
add_executable(hello_world &quot;main.cpp&quot;)

# WASI Config
if(WASI)
	set(CMAKE_EXE_LINKER_FLAGS &quot;-Wl,--allow-undefined&quot;)
	set(CMAKE_EXECUTABLE_SUFFIX &quot;.wasm&quot;)

	add_custom_command(TARGET hello_world
		POST_BUILD
		COMMAND sh -c &quot;wasm-opt --asyncify -O $&lt;TARGET_FILE:hello_world&gt; -o $&lt;TARGET_FILE:hello_world&gt;&quot;
		VERBATIM
	)
endif()
</code></pre>
<p>It allows compilation of both the native &amp; the WebAssembly target.</p>
<h3><a class="header" href="#make-configuration-3" id="make-configuration-3">Make Configuration</a></h3>
<p>See <a href="getting-started/develop/./c.html#make-configuration">C Hello, world! Make Configuration</a>.</p>
<h3><a class="header" href="#next-steps-4" id="next-steps-4">Next Steps</a></h3>
<p>See <a href="getting-started/develop/./c.html#next-steps">C Hello, world! Next Steps</a>.</p>
<h2><a class="header" href="#tcp-echo-server-1" id="tcp-echo-server-1">TCP Echo Server</a></h2>
<p>Webnetes has support for networking. Let's create a TCP echo server in C++ with native and WebAssembly targets. The full source code of this example is available on <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples/cpp_echo_server">GitHub</a>.</p>
<h3><a class="header" href="#source-code-4" id="source-code-4">Source Code</a></h3>
<p>Create <code>main.cpp</code> with the following content:</p>
<details>
	<summary>C++ Source</summary>
<pre><code class="language-cpp">extern &quot;C&quot; {
#include &quot;unisockets.h&quot;
}
#include &lt;arpa/inet.h&gt;
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;netinet/in.h&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;

const int BUFLEN_IN = 1024;
const int BUFLEN_OUT = 1038;

int main(int argc, char *argv[]) {
  // Flags
  std::string listen_host = &quot;127.0.0.1&quot;;
  int listen_port = 1234;

  int opt;
  while ((opt = getopt(argc, argv, &quot;l:p:&quot;)) != -1) {
    switch (opt) {
    case 'l':
      listen_host = optarg;

      optind--;

      break;

    case 'p':
      listen_port = std::stoi(optarg);

      break;

    default:
      std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; -l HOST -p PORT&quot; &lt;&lt; std::endl;

      return EXIT_FAILURE;
    }
  }

  // Address
  sockaddr_in server_address;
  server_address.sin_family = AF_INET;
  server_address.sin_port = htons(listen_port);
  if (inet_pton(AF_INET, listen_host.c_str(), &amp;server_address.sin_addr) == -1) {
    std::cout &lt;&lt; &quot;[ERROR] Could not parse IP address: &quot; &lt;&lt; strerror(errno)
              &lt;&lt; std::endl;

    return EXIT_FAILURE;
  }
  std::string server_address_readable =
      listen_host + &quot;:&quot; + std::to_string(listen_port);

  // Socket
  int server_socket;
  if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
    std::cout &lt;&lt; &quot;[ERROR] Could not create socket: &quot; &lt;&lt; strerror(errno)
              &lt;&lt; std::endl;

    return EXIT_FAILURE;
  }

  // Bind
  if ((bind(server_socket, reinterpret_cast&lt;sockaddr *&gt;(&amp;server_address),
            sizeof(server_address))) == -1) {
    std::cout &lt;&lt; &quot;[ERROR] Could not bind to socket: &quot; &lt;&lt; strerror(errno)
              &lt;&lt; std::endl;

    return EXIT_FAILURE;
  }

  // Listen
  if ((listen(server_socket, 5)) == -1) {
    std::cout &lt;&lt; &quot;[ERROR] Could not listen on socket: &quot; &lt;&lt; strerror(errno)
              &lt;&lt; std::endl;

    return EXIT_FAILURE;
  }

  std::cout &lt;&lt; &quot;[INFO] Listening on &quot; &lt;&lt; server_address_readable &lt;&lt; std::endl;

  // Accept loop
  for (;;) {
    std::cout &lt;&lt; &quot;[DEBUG] Accepting on &quot; &lt;&lt; server_address_readable
              &lt;&lt; std::endl;

    // Accept
    int client_socket;
    sockaddr_in client_address;
    socklen_t client_address_length;

    if ((client_socket = accept(
             server_socket, reinterpret_cast&lt;sockaddr *&gt;(&amp;client_address),
             &amp;(client_address_length = sizeof(client_address)))) == -1) {
      std::cout &lt;&lt; &quot;[ERROR] Could not accept, continuing: &quot; &lt;&lt; strerror(errno)
                &lt;&lt; std::endl;
    }

    char client_host[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &amp;client_address.sin_addr, client_host,
              sizeof(client_host));
    std::string client_address_readable =
        std::string(client_host) + &quot;:&quot; +
        std::to_string(client_address.sin_port);

    std::cout &lt;&lt; &quot;[INFO] Accepted client &quot; &lt;&lt; client_address_readable
              &lt;&lt; std::endl;

    // Receive loop
    for (;;) {
      std::cout &lt;&lt; &quot;[DEBUG] Waiting for client &quot; &lt;&lt; client_address_readable
                &lt;&lt; &quot; to send&quot; &lt;&lt; std::endl;

      // Receive
      int received_message_length = 1;
      char received_message[BUFLEN_IN] = &quot;&quot;;
      if ((received_message_length =
               recv(client_socket, &amp;received_message, BUFLEN_IN, 0)) == -1) {
        std::cout &lt;&lt; &quot;[ERROR] Could not receive from client &quot;
                  &lt;&lt; client_address_readable
                  &lt;&lt; &quot;, dropping message: &quot; &lt;&lt; strerror(errno) &lt;&lt; std::endl;
      } else if (received_message_length == 0) {
        break;
      }

      std::cout &lt;&lt; &quot;[DEBUG] Received &quot; &lt;&lt; received_message_length
                &lt;&lt; &quot; bytes from &quot; &lt;&lt; client_address_readable &lt;&lt; std::endl;

      // Process
      char sent_message[BUFLEN_OUT] = &quot;&quot;;
      sprintf((char *)(&amp;sent_message), &quot;You've sent: %s&quot;, received_message);
      sent_message[BUFLEN_OUT - 1] = '\0';

      // Send
      int sent_message_length = 0;
      if ((sent_message_length =
               send(client_socket, sent_message, BUFLEN_OUT, 0)) == -1) {
        std::cout &lt;&lt; &quot;[ERROR] Could not send to client &quot;
                  &lt;&lt; client_address_readable
                  &lt;&lt; &quot;, dropping message: &quot; &lt;&lt; strerror(errno) &lt;&lt; std::endl;
      }

      std::cout &lt;&lt; &quot;[DEBUG] Sent &quot; &lt;&lt; sent_message_length &lt;&lt; &quot; bytes to &quot;
                &lt;&lt; client_address_readable &lt;&lt; std::endl;
    }

    // Shutdown
    if ((shutdown(client_socket, SHUT_RDWR)) == -1) {
      std::cout &lt;&lt; &quot;[ERROR] Could not shutdown socket: &quot; &lt;&lt; strerror(errno)
                &lt;&lt; std::endl;

      return EXIT_FAILURE;
    }
  }

  return EXIT_SUCCESS;
}
</code></pre>
</details>
<p>It is a very simple TCP server that listens to messages, prefixes them with <code>You've sent: </code> and sends them back to the sender.</p>
<p>Now, copy and paste the <a href="https://github.com/alphahorizonio/webnetes/blob/main/examples/cpp_echo_server/unisockets.h">unisockets.h</a> header in the same directory as <code>main.cpp</code>, which allows networking to function.</p>
<h3><a class="header" href="#cmake-configuration-4" id="cmake-configuration-4">CMake Configuration</a></h3>
<p>Create <code>CMakeLists.txt</code> with the following content:</p>
<pre><code class="language-CMake">cmake_minimum_required(VERSION 3.13.4)

# WASI Config
if(WASI)
	set(WASI_SDK_PREFIX &quot;/opt/wasi-sdk-12.0&quot;)
	set(CMAKE_SYSROOT &quot;${WASI_SDK_PREFIX}/share/wasi-sysroot&quot;)
	set(CMAKE_TOOLCHAIN_FILE &quot;${WASI_SDK_PREFIX}/share/cmake/wasi-sdk.cmake&quot;)
endif()

# Project
project(echo_server)
add_executable(echo_server &quot;main.cpp&quot;)

# WASI Config
if(WASI)
	set(CMAKE_CXX_FLAGS &quot;-DUNISOCKETS_WITH_ALIAS&quot;)
	set(CMAKE_EXE_LINKER_FLAGS &quot;-Wl,--allow-undefined&quot;)
	set(CMAKE_EXECUTABLE_SUFFIX &quot;.wasm&quot;)

	add_custom_command(TARGET echo_server
		POST_BUILD
		COMMAND sh -c &quot;wasm-opt --asyncify -O $&lt;TARGET_FILE:echo_server&gt; -o $&lt;TARGET_FILE:echo_server&gt;&quot;
		VERBATIM
	)
endif()
</code></pre>
<p>It allows compilation of both the native &amp; the WebAssembly target. Note <code>-DUNISOCKETS_WITH_ALIAS</code>, which allows networking to function.</p>
<h3><a class="header" href="#make-configuration-4" id="make-configuration-4">Make Configuration</a></h3>
<p>See <a href="getting-started/develop/./c.html#make-configuration">C Hello, world! Make Configuration</a>.</p>
<h3><a class="header" href="#next-steps-5" id="next-steps-5">Next Steps</a></h3>
<p>See <a href="getting-started/develop/./c.html#next-steps-1">C TCP Echo Server Next Steps</a>.</p>
<h2><a class="header" href="#tcp-echo-client-1" id="tcp-echo-client-1">TCP Echo Client</a></h2>
<p>Now that we've got a TCP echo server, let's create a TCP echo client in C++ with native and WebAssembly targets. The full source code of this example is available on <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples/cpp_echo_client">GitHub</a>.</p>
<h3><a class="header" href="#source-code-5" id="source-code-5">Source Code</a></h3>
<p>Create <code>main.cpp</code> with the following content:</p>
<details>
	<summary>C++ Source</summary>
<pre><code class="language-cpp">extern &quot;C&quot; {
#include &quot;unisockets.h&quot;
}
#include &lt;arpa/inet.h&gt;
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;netinet/in.h&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;

const int BUFLEN_OUT = 1024;
const int BUFLEN_IN = 1038;
const int RECONNECT_TIMEOUT = 2;

int main(int argc, char *argv[]) {
  // Flags
  std::string connect_host = &quot;127.0.0.1&quot;;
  int connect_port = 1234;

  int opt;
  while ((opt = getopt(argc, argv, &quot;c:p:&quot;)) != -1) {
    switch (opt) {
    case 'c':
      connect_host = optarg;

      optind--;

      break;

    case 'p':
      connect_port = std::stoi(optarg);

      break;

    default:
      std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; -c HOST -p PORT&quot; &lt;&lt; std::endl;

      return EXIT_FAILURE;
    }
  }

  // Address
  sockaddr_in server_address;
  server_address.sin_family = AF_INET;
  server_address.sin_port = htons(connect_port);
  if (inet_pton(AF_INET, connect_host.c_str(), &amp;server_address.sin_addr) ==
      -1) {
    std::cout &lt;&lt; &quot;[ERROR] Could not parse IP address: &quot; &lt;&lt; strerror(errno)
              &lt;&lt; std::endl;

    return EXIT_FAILURE;
  }
  std::string server_address_readable =
      connect_host + &quot;:&quot; + std::to_string(connect_port);

  // Socket
  int server_socket;
  if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
    std::cout &lt;&lt; &quot;[ERROR] Could not create socket: &quot; &lt;&lt; strerror(errno)
              &lt;&lt; std::endl;

    return EXIT_FAILURE;
  }

  // Connect loop
  for (;;) {
    std::cout &lt;&lt; &quot;[INFO] Connecting to server &quot; &lt;&lt; server_address_readable
              &lt;&lt; std::endl;

    // Connect
    int server_address_length;
    if ((connect(server_socket, reinterpret_cast&lt;sockaddr *&gt;(&amp;server_address),
                 server_address_length = sizeof(server_address))) == -1) {
      std::cout &lt;&lt; &quot;[ERROR] Could not connect to server &quot;
                &lt;&lt; server_address_readable &lt;&lt; &quot;, retrying in &quot;
                &lt;&lt; RECONNECT_TIMEOUT &lt;&lt; &quot;s: &quot; &lt;&lt; strerror(errno) &lt;&lt; std::endl;

      sleep(RECONNECT_TIMEOUT);

      continue;
    }

    std::cout &lt;&lt; &quot;[INFO] Connected to server &quot; &lt;&lt; server_address_readable
              &lt;&lt; std::endl;

    // Read loop
    for (;;) {
      std::cout &lt;&lt; &quot;[DEBUG] Waiting for user input&quot; &lt;&lt; std::endl;

      // Read
      std::string read_message;
      std::getline(std::cin, read_message);
      read_message += &quot;\n&quot;;

      // Send
      int sent_message_length = 0;
      if ((sent_message_length = send(server_socket, read_message.c_str(),
                                      BUFLEN_OUT, 0)) == -1) {
        std::cout &lt;&lt; &quot;[ERROR] Could not send to server &quot;
                  &lt;&lt; server_address_readable
                  &lt;&lt; &quot;, dropping message: &quot; &lt;&lt; strerror(errno) &lt;&lt; std::endl;
      }

      std::cout &lt;&lt; &quot;[DEBUG] Sent &quot; &lt;&lt; sent_message_length &lt;&lt; &quot; bytes to &quot;
                &lt;&lt; server_address_readable &lt;&lt; std::endl;

      std::cout &lt;&lt; &quot;[DEBUG] Waiting for server &quot; &lt;&lt; server_address_readable
                &lt;&lt; &quot; to send&quot; &lt;&lt; std::endl;

      // Receive
      int received_message_length = 1;
      char received_message[BUFLEN_IN] = &quot;&quot;;
      if ((received_message_length =
               recv(server_socket, &amp;received_message, BUFLEN_IN, 0)) == -1) {
        std::cout &lt;&lt; &quot;[ERROR] Could not receive from service &quot;
                  &lt;&lt; server_address_readable
                  &lt;&lt; &quot;, dropping message: &quot; &lt;&lt; strerror(errno) &lt;&lt; std::endl;
      } else if (received_message_length == 0) {
        break;
      }

      std::cout &lt;&lt; &quot;[DEBUG] Received &quot; &lt;&lt; received_message_length
                &lt;&lt; &quot; bytes from &quot; &lt;&lt; server_address_readable &lt;&lt; std::endl;

      // Print
      std::cout &lt;&lt; received_message;
    }
  }

  std::cout &lt;&lt; &quot;[INFO] Disconnected from server &quot; &lt;&lt; server_address_readable
            &lt;&lt; std::endl;

  // Shutdown
  if ((shutdown(server_socket, SHUT_RDWR)) == -1) {
    std::cout &lt;&lt; &quot;[ERROR] Could not shutdown socket: &quot; &lt;&lt; strerror(errno)
              &lt;&lt; std::endl;

    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}
</code></pre>
</details>
<p>It is a very simple TCP client that reads a message from standard input, sends it to the server, waits for a reply, and prints it to standard out.</p>
<p>Now, copy and paste the <a href="https://github.com/alphahorizonio/webnetes/blob/main/examples/cpp_echo_client/unisockets.h">unisockets.h</a> header in the same directory as <code>main.cpp</code>, which allows networking to function.</p>
<h3><a class="header" href="#cmake-configuration-5" id="cmake-configuration-5">CMake Configuration</a></h3>
<p>Create <code>CMakeLists.txt</code> with the following content:</p>
<pre><code class="language-CMake">cmake_minimum_required(VERSION 3.13.4)

# WASI Config
if(WASI)
	set(WASI_SDK_PREFIX &quot;/opt/wasi-sdk-12.0&quot;)
	set(CMAKE_SYSROOT &quot;${WASI_SDK_PREFIX}/share/wasi-sysroot&quot;)
	set(CMAKE_TOOLCHAIN_FILE &quot;${WASI_SDK_PREFIX}/share/cmake/wasi-sdk.cmake&quot;)
endif()

# Project
project(echo_client)
add_executable(echo_client &quot;main.cpp&quot;)

# WASI Config
if(WASI)
	set(CMAKE_CXX_FLAGS &quot;-DUNISOCKETS_WITH_ALIAS&quot;)
	set(CMAKE_EXE_LINKER_FLAGS &quot;-Wl,--allow-undefined&quot;)
	set(CMAKE_EXECUTABLE_SUFFIX &quot;.wasm&quot;)

	add_custom_command(TARGET echo_client
		POST_BUILD
		COMMAND sh -c &quot;wasm-opt --asyncify -O $&lt;TARGET_FILE:echo_client&gt; -o $&lt;TARGET_FILE:echo_client&gt;&quot;
		VERBATIM
	)
endif()
</code></pre>
<p>It allows compilation of both the native &amp; the WebAssembly target. Note <code>-DUNISOCKETS_WITH_ALIAS</code>, which allows networking to function.</p>
<h3><a class="header" href="#make-configuration-5" id="make-configuration-5">Make Configuration</a></h3>
<p>See <a href="getting-started/develop/./c.html#make-configuration">C Hello, world! Make Configuration</a>.</p>
<h3><a class="header" href="#next-steps-6" id="next-steps-6">Next Steps</a></h3>
<p>See <a href="getting-started/develop/./c.html#next-steps-2">C TCP Echo Client Next Steps</a>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/WebAssembly/threads">WebAssembly threads</a> are not yet implemented.</p>
</div>
<h1><a class="header" href="#go" id="go">Go</a></h1>
<h2><a class="header" href="#table-of-contents-2" id="table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="getting-started/develop/go.html#language-support-status">Language Support Status</a></li>
<li><a href="getting-started/develop/go.html#hello-world">Hello, world!</a>
<ul>
<li><a href="getting-started/develop/go.html#module">Module</a></li>
<li><a href="getting-started/develop/go.html#source-code">Source Code</a></li>
<li><a href="getting-started/develop/go.html#make-configuration">Make Configuration</a></li>
<li><a href="getting-started/develop/go.html#next-steps">Next Steps</a></li>
</ul>
</li>
<li><a href="getting-started/develop/go.html#tcp-chat-server">TCP Chat Server</a>
<ul>
<li><a href="getting-started/develop/go.html#module-1">Module</a></li>
<li><a href="getting-started/develop/go.html#source-code-1">Source Code</a></li>
<li><a href="getting-started/develop/go.html#make-configuration-1">Make Configuration</a></li>
<li><a href="getting-started/develop/go.html#next-steps-1">Next Steps</a></li>
</ul>
</li>
<li><a href="getting-started/develop/go.html#tcp-chat-client">TCP Chat Client</a>
<ul>
<li><a href="getting-started/develop/go.html#module-2">Module</a></li>
<li><a href="getting-started/develop/go.html#source-code-2">Source Code</a></li>
<li><a href="getting-started/develop/go.html#make-configuration-2">Make Configuration</a></li>
<li><a href="getting-started/develop/go.html#next-steps-2">Next Steps</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#language-support-status-2" id="language-support-status-2">Language Support Status</a></h2>
<table><thead><tr><th>Native</th><th>WebAssembly</th><th>Networking</th><th>Concurrency</th></tr></thead><tbody>
<tr><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr>
</tbody></table>
<p>Go &amp; <a href="https://tinygo.org/">TinyGo</a> are supported, but the latter only has limited support for concurrency.</p>
<h2><a class="header" href="#hello-world-2" id="hello-world-2">Hello, world!</a></h2>
<p>Let's start by writing a hello world app in Go with native and WebAssembly targets. The full source code of this example is available on <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples/go_hello_world">GitHub</a>.</p>
<h3><a class="header" href="#module" id="module">Module</a></h3>
<p>Run the following to initialize your module:</p>
<pre><code class="language-shell">$ go mod init module github.com/myuser/mymodule
</code></pre>
<p>Don't forget to change <code>github.com/myuser/mymodule</code> to a more appropriate module path.</p>
<h3><a class="header" href="#source-code-6" id="source-code-6">Source Code</a></h3>
<p>Create <code>main.go</code> with the following content:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;Hello, world!&quot;)
}
</code></pre>
<p>It prints <code>Hello, world!</code> to standard output.</p>
<h3><a class="header" href="#make-configuration-6" id="make-configuration-6">Make Configuration</a></h3>
<p>Create a <code>Makefile</code> with the following content:</p>
<pre><code class="language-Makefile">all: native-go native-tinygo wasm-go wasm-tinygo

native-go:
	@docker run -v ${PWD}:/src:z -v ${PWD}/.go:/go:z golang sh -c 'cd /src &amp;&amp; go build -o out/go/hello_world main.go'

native-tinygo:
	@docker run -v ${PWD}:/src:z -v ${PWD}/.go:/root/go:z tinygo/tinygo sh -c 'cd /src &amp;&amp; mkdir -p out/tinygo &amp;&amp; tinygo build -o out/tinygo/hello_world main.go'

wasm-go:
	@docker run -v ${PWD}:/src:z -v ${PWD}/.go:/go:z -e GOOS=js -e GOARCH=wasm golang sh -c 'cd /src &amp;&amp; go build -o out/go/hello_world.wasm main.go'

wasm-tinygo:
	@docker run -v ${PWD}:/src:z -v ${PWD}/.go:/root/go:z tinygo/tinygo sh -c 'cd /src &amp;&amp; mkdir -p out/tinygo &amp;&amp; tinygo build -heap-size 20M -target wasi -o out/tinygo/hello_world.wasm main.go'
	@docker run -v ${PWD}:/src:z alphahorizonio/wasi-sdk sh -c 'cd /src &amp;&amp; wasm-opt --asyncify -O out/tinygo/hello_world.wasm -o out/tinygo/hello_world.wasm'

clean:
	@rm -rf out

seed-go: wasm-go
	@docker run -it -v ${PWD}/out:/out:z --entrypoint=/bin/sh schaurian/webtorrent-hybrid -c &quot;/usr/local/bin/webtorrent-hybrid seed /out/go/*.wasm&quot;

seed-tinygo: wasm-tinygo
	@docker run -it -v ${PWD}/out:/out:z --entrypoint=/bin/sh schaurian/webtorrent-hybrid -c &quot;/usr/local/bin/webtorrent-hybrid seed /out/tinygo/*.wasm&quot;
</code></pre>
<p>It provides eight targets:</p>
<ul>
<li><code>make</code> builds both the native &amp; the WebAssembly target for both Go &amp; TinyGo</li>
<li><code>make native-go</code> builds only the native target, using Go</li>
<li><code>make native-tinygo</code> builds only the native target, using TinyGo</li>
<li><code>make wasm-go</code> builds only the WebAssembly target, using Go</li>
<li><code>make wasm-tinyoo</code> builds only the WebAssembly target, using TinyGo</li>
<li><code>make clean</code> removes the built targets</li>
<li><code>make seed-go</code> seeds the WebAssembly target built with Go, which will come in handy later.</li>
<li><code>make seed-tinygo</code> seeds the WebAssembly target built with TinyGo, which will come in handy later.</li>
</ul>
<p>All of them use Docker, so there is no need to install any dependencies on the host.</p>
<h3><a class="header" href="#next-steps-7" id="next-steps-7">Next Steps</a></h3>
<p>Build all targets:</p>
<pre><code class="language-shell">$ make
</code></pre>
<p>Run the native Go target:</p>
<pre><code class="language-shell">$ ./out/go/hello_world
Hello, world!
</code></pre>
<p>Run the native TinyGo target:</p>
<pre><code class="language-shell">$ ./out/tinygo/hello_world
Hello, world!
</code></pre>
<p>The native targets work! Now continue to <a href="getting-started/develop/../distribute.html">Distribute</a> to learn how to run the WebAssembly targets.</p>
<h2><a class="header" href="#tcp-chat-server" id="tcp-chat-server">TCP Chat Server</a></h2>
<p>Webnetes has support for networking. Let's create a TCP chat server in Go with native and WebAssembly targets. The full source code of this example is available on <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples/go_chat_server">GitHub</a>.</p>
<h3><a class="header" href="#module-1" id="module-1">Module</a></h3>
<p>See <a href="getting-started/develop/go.html#module">Hello, world! Module</a>.</p>
<h3><a class="header" href="#source-code-7" id="source-code-7">Source Code</a></h3>
<p>Create <code>main.go</code> with the following content:</p>
<details>
	<summary>Go Source</summary>
<pre><code class="language-go">package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;log&quot;

	&quot;github.com/alphahorizonio/tinynet/pkg/tinynet&quot;
	&quot;github.com/google/uuid&quot;
	&quot;github.com/ugjka/messenger&quot;
)

func main() {
	// Parse flags
	laddr := flag.String(&quot;laddr&quot;, &quot;127.0.0.1:4206&quot;, &quot;Address to listen on&quot;)
	flag.Parse()

	// Listen
	lis, err := tinynet.Listen(&quot;tcp&quot;, *laddr)
	if err != nil {
		log.Fatal(&quot;could not listen&quot;, err)
	}

	log.Println(&quot;Listening on&quot;, *laddr)

	// Receive &amp; broadcast
	msgr := messenger.New(0, true)
	for {
		// Accept
		conn, err := lis.Accept()
		if err != nil {
			log.Fatal(&quot;could not accept&quot;, err)
		}

		// Notify peers of new node
		log.Println(&quot;Client connected&quot;)
		clientID := uuid.New()
		msgr.Broadcast(fmt.Sprintf(&quot;&lt;system&gt;:\tClient %v joined\n&quot;, clientID.String()))

		// Receive from clients &amp; send to bus
		go func(innerConn tinynet.Conn) {
			for {
				// Receive
				buf := make([]byte, 1024)
				if n, err := innerConn.Read(buf); err != nil {
					if n == 0 {
						break
					}

					log.Println(&quot;could not read from connection, removing connection&quot;, err)

					break
				}

				// Send to bus
				msgr.Broadcast(fmt.Sprintf(&quot;&lt;%v&gt;:\t%v&quot;, clientID.String(), string(buf)))
			}

			// Close client socket
			log.Println(&quot;Client disconnected&quot;)

			_ = innerConn.Close() // We keep closing to the OS
		}(conn)

		// Receive from bus &amp; broadcast to clients
		go func(innerConn tinynet.Conn) {
			// Subscribe to new messages
			bus, err := msgr.Sub()
			if err != nil {
				log.Println(&quot;could not subscribe to broadcasted messages&quot;, err)
			}
			defer msgr.Unsub(bus)

			for msg := range bus {
				// Send to client
				if n, err := innerConn.Write([]byte(fmt.Sprintf(&quot;%v&quot;, msg))); err != nil {
					if n == 0 {
						break
					}

					fmt.Println(&quot;could not write to connection, removing connection&quot;, err)

					break
				}
			}

			// Close client socket
			log.Println(&quot;Client disconnected&quot;)

			_ = innerConn.Close() // We keep closing to the OS
		}(conn)
	}
}
</code></pre>
</details>
<p>It is a very simple TCP server that listens to messages, assigns an ID to clients, and broadcasts the messages to every other client.</p>
<h3><a class="header" href="#make-configuration-7" id="make-configuration-7">Make Configuration</a></h3>
<p>Create a <code>Makefile</code> with the following content:</p>
<pre><code class="language-Makefile">all: native wasm

native:
	@docker run -v ${PWD}:/src:z -v ${PWD}/.go:/go:z golang sh -c 'cd /src &amp;&amp; go build -o out/go/chat_server main.go'

wasm:
	@docker run -v ${PWD}:/src:z -v ${PWD}/.go:/go:z -e GOOS=js -e GOARCH=wasm golang sh -c 'cd /src &amp;&amp; go build -o out/go/chat_server.wasm main.go'

clean:
	@rm -rf out

seed: wasm
	@docker run -it -v ${PWD}/out:/out:z --entrypoint=/bin/sh schaurian/webtorrent-hybrid -c &quot;/usr/local/bin/webtorrent-hybrid seed /out/go/*.wasm&quot;
</code></pre>
<p>It provides five targets:</p>
<ul>
<li><code>make</code> builds both the native &amp; the WebAssembly target</li>
<li><code>make native</code> builds only the native target</li>
<li><code>make wasm</code> builds only the WebAssembly target</li>
<li><code>make clean</code> removes the built targets</li>
<li><code>make seed</code> seeds the WebAssembly target, which will come in handy later.</li>
</ul>
<p>All of them use Docker, so there is no need to install any dependencies on the host.</p>
<h3><a class="header" href="#next-steps-8" id="next-steps-8">Next Steps</a></h3>
<p>Build the native target:</p>
<pre><code class="language-shell">$ make native
</code></pre>
<p>Run the native target:</p>
<pre><code class="language-shell">$ ./out/go/chat_server
2021/01/24 17:48:43 Listening on 127.0.0.1:4206
</code></pre>
<p>In a second terminal, connect to the server:</p>
<pre><code class="language-shell">$ nc localhost 4206
</code></pre>
<p>The server should now display the following:</p>
<pre><code class="language-shell">2021/01/24 17:49:07 Client connected
</code></pre>
<p>If you type something into the second terminal and press <kbd>Enter</kbd>, the server should echo it as follows:</p>
<pre><code class="language-shell">Hello, reader!
&lt;25b81b38-5ad5-4478-931f-564f2fd313f7&gt;: Hello, reader!
</code></pre>
<p>Let's open up another terminal:</p>
<pre><code class="language-shell">$ nc localhost 4206
</code></pre>
<p>The second terminal should now contain a message like this:</p>
<pre><code class="language-shell">&lt;system&gt;:       Client 80f9391f-7eea-45f6-9b50-1f0482bee9e7 joined
</code></pre>
<p>If you type something into the third terminal and press <kbd>Enter</kbd>, the server should echo it to as follows:</p>
<pre><code class="language-shell">Hello from client 2 in terminal 3!
&lt;80f9391f-7eea-45f6-9b50-1f0482bee9e7&gt;: Hello from client 2 in terminal 3!
</code></pre>
<p>The second terminal should now also contain your message:</p>
<pre><code>&lt;80f9391f-7eea-45f6-9b50-1f0482bee9e7&gt;: Hello from client 2 in terminal 3!
</code></pre>
<p>The native target works! Now continue to <a href="getting-started/develop/../distribute.html">Distribute</a> to learn how to run the WebAssembly target.</p>
<h2><a class="header" href="#tcp-chat-client" id="tcp-chat-client">TCP Chat Client</a></h2>
<p>Now that we've got a TCP chat server, let's create a TCP chat client in Go with native and WebAssembly targets. The full source code of this example is available on <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples/go_chat_client">GitHub</a>.</p>
<h3><a class="header" href="#module-2" id="module-2">Module</a></h3>
<p>See <a href="getting-started/develop/go.html#module">Hello, world! Module</a>.</p>
<h3><a class="header" href="#source-code-8" id="source-code-8">Source Code</a></h3>
<p>Create <code>main.go</code> with the following content:</p>
<details>
	<summary>Go Source</summary>
<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;sync&quot;

	&quot;github.com/alphahorizonio/tinynet/pkg/tinynet&quot;
)

func main() {
	// Parse flags
	raddr := flag.String(&quot;raddr&quot;, &quot;127.0.0.1:4206&quot;, &quot;Address to connect to&quot;)
	flag.Parse()

	// Dial
	conn, err := tinynet.Dial(&quot;tcp&quot;, *raddr)
	if err != nil {
		fmt.Println(&quot;could not dial&quot;, err)

		os.Exit(1)
	}

	fmt.Println(&quot;Connected to&quot;, *raddr)

	var wg sync.WaitGroup
	wg.Add(2)

	// Read from stdin &amp; send
	go func(innerWg *sync.WaitGroup) {
		reader := bufio.NewReader(os.Stdin)
		for {
			out, err := reader.ReadString('\n')
			if err != nil {
				fmt.Println(&quot;could not read from stdin&quot;, err)

				os.Exit(1)
			}

			if n, err := conn.Write([]byte(out)); err != nil {
				if n == 0 {
					break
				}

				fmt.Println(&quot;could not write from connection, removing connection&quot;, err)

				break
			}
		}

		fmt.Println(&quot;Disconnected&quot;)

		if err := conn.Close(); err != nil {
			fmt.Println(&quot;could not close connection&quot;, err)
		}

		innerWg.Done()
	}(&amp;wg)

	// Receive &amp; print
	go func(innerWg *sync.WaitGroup) {
		for {
			buf := make([]byte, 1038)
			if n, err := conn.Read(buf); err != nil {
				if n == 0 {
					break
				}

				fmt.Println(&quot;could not read from connection, removing connection&quot;, err)

				break
			}

			fmt.Printf(&quot;%v&quot;, string(buf))
		}

		fmt.Println(&quot;Disconnected&quot;)

		if err := conn.Close(); err != nil {
			fmt.Println(&quot;could not close connection&quot;, err)
		}

		innerWg.Done()
	}(&amp;wg)

	wg.Wait()
}
</code></pre>
</details>
<p>It is a very simple TCP client that reads a message from standard input and sends it to the server. In another Goroutine, it waits for any messages from the server, and prints them to standard out.</p>
<h3><a class="header" href="#make-configuration-8" id="make-configuration-8">Make Configuration</a></h3>
<p>Create a <code>Makefile</code> with the following content:</p>
<pre><code class="language-Makefile">all: native wasm

native:
	@docker run -v ${PWD}:/src:z -v ${PWD}/.go:/go:z golang sh -c 'cd /src &amp;&amp; go build -o out/go/chat_client main.go'

wasm:
	@docker run -v ${PWD}:/src:z -v ${PWD}/.go:/go:z -e GOOS=js -e GOARCH=wasm golang sh -c 'cd /src &amp;&amp; go build -o out/go/chat_client.wasm main.go'

clean:
	@rm -rf out

seed: wasm
	@docker run -it -v ${PWD}/out:/out:z --entrypoint=/bin/sh schaurian/webtorrent-hybrid -c &quot;/usr/local/bin/webtorrent-hybrid seed /out/go/*.wasm&quot;
</code></pre>
<p>It provides five targets:</p>
<ul>
<li><code>make</code> builds both the native &amp; the WebAssembly target</li>
<li><code>make native</code> builds only the native target</li>
<li><code>make wasm</code> builds only the WebAssembly target</li>
<li><code>make clean</code> removes the built targets</li>
<li><code>make seed</code> seeds the WebAssembly target, which will come in handy later.</li>
</ul>
<p>All of them use Docker, so there is no need to install any dependencies on the host.</p>
<h3><a class="header" href="#next-steps-9" id="next-steps-9">Next Steps</a></h3>
<p>First, <a href="getting-started/develop/go.html#next-steps-1">build and run the TCP chat server</a>.</p>
<p>In a second terminal, build the native target:</p>
<pre><code class="language-shell">$ make native
</code></pre>
<p>Run the native target:</p>
<pre><code class="language-shell">$ ./out/go/chat_client
Connected to 127.0.0.1:4206
</code></pre>
<p>The server should now display the following:</p>
<pre><code class="language-shell">2021/01/24 18:00:47 Client connected
</code></pre>
<p>If you type something into the terminal and press <kbd>Enter</kbd>, the server should echo it as follows:</p>
<pre><code class="language-shell">Hello from the native Go chat client!
&lt;c22c532b-bd68-42d6-b2d3-bf69cf0dce8b&gt;: Hello from the native Go chat client!
</code></pre>
<p>The native target works! Now continue to <a href="getting-started/develop/../distribute.html">Distribute</a> to learn how to run the WebAssembly target.</p>
<h1><a class="header" href="#rust" id="rust">Rust</a></h1>
<h2><a class="header" href="#table-of-contents-3" id="table-of-contents-3">Table of Contents</a></h2>
<ul>
<li><a href="getting-started/develop/rust.html#language-support-status">Language Support Status</a></li>
<li><a href="getting-started/develop/rust.html#hello-world">Hello, world!</a>
<ul>
<li><a href="getting-started/develop/rust.html#crate">Crate</a></li>
<li><a href="getting-started/develop/rust.html#source-code">Source Code</a></li>
<li><a href="getting-started/develop/rust.html#make-configuration">Make Configuration</a></li>
<li><a href="getting-started/develop/rust.html#next-steps">Next Steps</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#language-support-status-3" id="language-support-status-3">Language Support Status</a></h2>
<table><thead><tr><th>Native</th><th>WebAssembly</th><th>Networking</th><th>Concurrency</th></tr></thead><tbody>
<tr><td>✅</td><td>✅</td><td>❌<sup class="footnote-reference"><a href="#1">1</a></sup></td><td>✅</td></tr>
</tbody></table>
<h2><a class="header" href="#hello-world-3" id="hello-world-3">Hello, world!</a></h2>
<p>Let's start by writing a hello world app in Rust with native and WebAssembly targets. The full source code of this example is available on <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples/rust_hello_world">GitHub</a>.</p>
<h3><a class="header" href="#crate" id="crate">Crate</a></h3>
<p>Run the following to initialize your crate:</p>
<pre><code class="language-shell">$ cargo new --bin rust_hello_world
</code></pre>
<h3><a class="header" href="#source-code-9" id="source-code-9">Source Code</a></h3>
<p>Replace <code>src/main.rs</code> with the following content:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>It prints <code>Hello, world!</code> to standard output.</p>
<h3><a class="header" href="#make-configuration-9" id="make-configuration-9">Make Configuration</a></h3>
<p>Create a <code>Makefile</code> with the following content:</p>
<pre><code class="language-Makefile">all: native wasm

native:
	@docker run -v ${PWD}:/src:z -v ${PWD}/.cargo:/usr/local/cargo/registry:z alphahorizonio/rust-sdk sh -c 'cd /src &amp;&amp; cargo build --release'

wasm:
	@docker run -v ${PWD}:/src:z -v ${PWD}/.cargo:/usr/local/cargo/registry:z alphahorizonio/rust-sdk sh -c 'cd /src &amp;&amp; cargo build --release --target wasm32-wasi'
	@docker run -v ${PWD}:/src:z alphahorizonio/wasi-sdk sh -c 'cd /src &amp;&amp; wasm-opt --asyncify -O target/wasm32-wasi/release/rust_hello_world.wasm -o target/wasm32-wasi/release/rust_hello_world.wasm'

clean:
	@rm -rf target

seed: clean wasm
	@docker run -it -v ${PWD}/target:/target:z --entrypoint=/bin/sh schaurian/webtorrent-hybrid -c &quot;/usr/local/bin/webtorrent-hybrid seed /target/wasm32-wasi/release/*.wasm&quot;
</code></pre>
<p>It provides five targets:</p>
<ul>
<li><code>make</code> builds both the native &amp; the WebAssembly target</li>
<li><code>make native</code> builds only the native target</li>
<li><code>make wasm</code> builds only the WebAssembly target</li>
<li><code>make clean</code> removes the built targets</li>
<li><code>make seed</code> seeds the WebAssembly target, which will come in handy later.</li>
</ul>
<p>All of them use Docker, so there is no need to install any dependencies on the host.</p>
<h3><a class="header" href="#next-steps-10" id="next-steps-10">Next Steps</a></h3>
<p>Build the native target:</p>
<pre><code class="language-shell">$ make native
</code></pre>
<p>Run the native target:</p>
<pre><code class="language-shell">$ ./target/release/rust_hello_world
Hello, world!
</code></pre>
<p>The native target works! Now continue to <a href="getting-started/develop/../distribute.html">Distribute</a> to learn how to run the WebAssembly target.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>No Rust bindings to <a href="https://github.com/alphahorizonio/unisockets">unisockets</a> have been implemented yet.</p>
</div>
<h1><a class="header" href="#zig" id="zig">Zig</a></h1>
<h2><a class="header" href="#table-of-contents-4" id="table-of-contents-4">Table of Contents</a></h2>
<ul>
<li><a href="getting-started/develop/zig.html#language-support-status">Language Support Status</a></li>
<li><a href="getting-started/develop/zig.html#hello-world">Hello, world!</a>
<ul>
<li><a href="getting-started/develop/zig.html#source-code">Source Code</a></li>
<li><a href="getting-started/develop/zig.html#make-configuration">Make Configuration</a></li>
<li><a href="getting-started/develop/zig.html#next-steps">Next Steps</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#language-support-status-4" id="language-support-status-4">Language Support Status</a></h2>
<table><thead><tr><th>Native</th><th>WebAssembly</th><th>Networking</th><th>Concurrency</th></tr></thead><tbody>
<tr><td>✅</td><td>✅</td><td>❌<sup class="footnote-reference"><a href="#1">1</a></sup></td><td>✅</td></tr>
</tbody></table>
<h2><a class="header" href="#hello-world-4" id="hello-world-4">Hello, world!</a></h2>
<p>Let's start by writing a hello world app in Zig with native and WebAssembly targets. The full source code of this example is available on <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples/zig_hello_world">GitHub</a>.</p>
<h3><a class="header" href="#source-code-10" id="source-code-10">Source Code</a></h3>
<p>Create <code>main.zig</code> with the following content:</p>
<pre><code class="language-zig">const std = @import(&quot;std&quot;);

pub fn main() !void {
    const stdout = std.io.getStdOut().outStream();
    try stdout.print(&quot;Hello, world!\n&quot;, .{});
}
</code></pre>
<p>It prints <code>Hello, world!</code> to standard output.</p>
<h3><a class="header" href="#make-configuration-10" id="make-configuration-10">Make Configuration</a></h3>
<p>Create a <code>Makefile</code> with the following content:</p>
<pre><code class="language-Makefile">all: native wasm

native:
	@docker run -v ${PWD}:/src:z alphahorizonio/zig-sdk sh -c 'cd /src &amp;&amp; zig build-exe --output-dir out main.zig'

wasm:
	@docker run -v ${PWD}:/src:z alphahorizonio/zig-sdk sh -c 'cd /src &amp;&amp; zig build-exe --output-dir out -target wasm32-wasi main.zig'
	@docker run -v ${PWD}:/src:z alphahorizonio/wasi-sdk sh -c 'cd /src &amp;&amp; wasm-opt --asyncify -O out/main.wasm -o out/main.wasm'

clean:
	@rm -rf out

seed: wasm
	@docker run -it -v ${PWD}/out:/out:z --entrypoint=/bin/sh schaurian/webtorrent-hybrid -c &quot;/usr/local/bin/webtorrent-hybrid seed /out/*.wasm&quot;
</code></pre>
<p>It provides five targets:</p>
<ul>
<li><code>make</code> builds both the native &amp; the WebAssembly target</li>
<li><code>make native</code> builds only the native target</li>
<li><code>make wasm</code> builds only the WebAssembly target</li>
<li><code>make clean</code> removes the built targets</li>
<li><code>make seed</code> seeds the WebAssembly target, which will come in handy later.</li>
</ul>
<p>All of them use Docker, so there is no need to install any dependencies on the host.</p>
<h3><a class="header" href="#next-steps-11" id="next-steps-11">Next Steps</a></h3>
<p>Build the native target:</p>
<pre><code class="language-shell">$ make native
</code></pre>
<p>Run the native target:</p>
<pre><code class="language-shell">$ ./out/main
Hello, world!
</code></pre>
<p>The native target works! Now continue to <a href="getting-started/develop/../distribute.html">Distribute</a> to learn how to run the WebAssembly target.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>No Zig bindings to <a href="https://github.com/alphahorizonio/unisockets">unisockets</a> have been implemented yet.</p>
</div>
<h1><a class="header" href="#java" id="java">Java</a></h1>
<h2><a class="header" href="#table-of-contents-5" id="table-of-contents-5">Table of Contents</a></h2>
<ul>
<li><a href="getting-started/develop/java.html#language-support-status">Language Support Status</a></li>
<li><a href="getting-started/develop/java.html#hello-world">Hello, world!</a>
<ul>
<li><a href="getting-started/develop/java.html#pom">POM</a></li>
<li><a href="getting-started/develop/java.html#source-code">Source Code</a></li>
<li><a href="getting-started/develop/java.html#make-configuration">Make Configuration</a></li>
<li><a href="getting-started/develop/java.html#next-steps">Next Steps</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#language-support-status-5" id="language-support-status-5">Language Support Status</a></h2>
<table><thead><tr><th>Native</th><th>WebAssembly</th><th>Networking</th><th>Concurrency</th></tr></thead><tbody>
<tr><td>✅</td><td>✅</td><td>❌<sup class="footnote-reference"><a href="#1">1</a></sup></td><td>✅</td></tr>
</tbody></table>
<h2><a class="header" href="#hello-world-5" id="hello-world-5">Hello, world!</a></h2>
<p>Let's start by writing a hello world app in Java with native and WebAssembly targets. The full source code of this example is available on <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples/rust_hello_world">GitHub</a>.</p>
<h3><a class="header" href="#pom" id="pom">POM</a></h3>
<p>Create <code>pom.xml</code> with the following content:</p>
<details>
	<summary>XML Source</summary>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;dev.webnetes.examples.java.hello_world&lt;/groupId&gt;
    &lt;artifactId&gt;hello_world&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;teavm.version&gt;0.7.0-dev-1145&lt;/teavm.version&gt;
        &lt;mainClass&gt;dev.webnetes.examples.java.hello_world.Application&lt;/mainClass&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.teavm&lt;/groupId&gt;
            &lt;artifactId&gt;teavm-classlib&lt;/artifactId&gt;
            &lt;version&gt;${teavm.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.teavm&lt;/groupId&gt;
            &lt;artifactId&gt;teavm-metaprogramming-impl&lt;/artifactId&gt;
            &lt;version&gt;${teavm.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.1.2&lt;/version&gt;
            &lt;type&gt;maven-plugin&lt;/type&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;central&lt;/id&gt;
            &lt;name&gt;Maven Central&lt;/name&gt;
            &lt;layout&gt;default&lt;/layout&gt;
            &lt;url&gt;https://repo1.maven.org/maven2&lt;/url&gt;
        &lt;/repository&gt;

        &lt;repository&gt;
            &lt;id&gt;teavm-dev&lt;/id&gt;
            &lt;url&gt;https://dl.bintray.com/konsoletyper/teavm&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;central&lt;/id&gt;
            &lt;name&gt;Maven Central&lt;/name&gt;
            &lt;layout&gt;default&lt;/layout&gt;
            &lt;url&gt;https://repo1.maven.org/maven2&lt;/url&gt;
        &lt;/pluginRepository&gt;

        &lt;pluginRepository&gt;
            &lt;id&gt;teavm-dev&lt;/id&gt;
            &lt;url&gt;https://dl.bintray.com/konsoletyper/teavm&lt;/url&gt;
        &lt;/pluginRepository&gt;
    &lt;/pluginRepositories&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;${java.version}&lt;/source&gt;
                    &lt;target&gt;${java.version}&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;

            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.2.4&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;shade&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;transformers&gt;
                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;
                                    &lt;manifestEntries&gt;
                                        &lt;Main-Class&gt;${mainClass}&lt;/Main-Class&gt;
                                    &lt;/manifestEntries&gt;
                                &lt;/transformer&gt;
                            &lt;/transformers&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;

            &lt;plugin&gt;
                &lt;groupId&gt;org.teavm&lt;/groupId&gt;
                &lt;artifactId&gt;teavm-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;${teavm.version}&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;web-client&lt;/id&gt;
                        &lt;phase&gt;prepare-package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;compile&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;mainClass&gt;${mainClass}&lt;/mainClass&gt;
                            &lt;optimizationLevel&gt;FULL&lt;/optimizationLevel&gt;
                            &lt;targetType&gt;WEBASSEMBLY&lt;/targetType&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
</details>
<p>Don't forget to change <code>groupId</code> etc. to more appropriate values.</p>
<h3><a class="header" href="#source-code-11" id="source-code-11">Source Code</a></h3>
<p>Create <code>src/main/java/dev/webnetes/examples/java/hello_world/Application.java</code> with the following content:</p>
<pre><code class="language-java">package dev.webnetes.examples.java.hello_world;

public class Application {
    public static void main(String[] args) {
        System.out.println(&quot;Hello, world!&quot;);
    }
}
</code></pre>
<p>It prints <code>Hello, world!</code> to standard output.</p>
<h3><a class="header" href="#make-configuration-11" id="make-configuration-11">Make Configuration</a></h3>
<p>Create a <code>Makefile</code> with the following content:</p>
<pre><code class="language-Makefile">all:
	@docker run -v ${PWD}:/src:z -v ${PWD}/.m2:/root/.m2:z maven sh -c 'cd /src &amp;&amp; mvn clean install'
	@docker run -v ${PWD}:/src:z alphahorizonio/wasi-sdk sh -c 'cd /src &amp;&amp; wasm-opt --asyncify -O target/javascript/classes.wasm -o target/javascript/classes.wasm'

clean:
	@rm -rf target

seed: all
	@docker run -it -v ${PWD}/target:/target:z --entrypoint=/bin/sh schaurian/webtorrent-hybrid -c &quot;/usr/local/bin/webtorrent-hybrid seed /target/javascript/classes.wasm&quot;
</code></pre>
<p>It provides three targets:</p>
<ul>
<li><code>make</code> builds both the native &amp; the WebAssembly target</li>
<li><code>make clean</code> removes the built targets</li>
<li><code>make seed</code> seeds the WebAssembly target, which will come in handy later.</li>
</ul>
<p>All of them use Docker, so there is no need to install any dependencies on the host.</p>
<h3><a class="header" href="#next-steps-12" id="next-steps-12">Next Steps</a></h3>
<p>Build the native &amp; the WebAssembly target:</p>
<pre><code class="language-shell">$ make
</code></pre>
<p>Run the native target:</p>
<pre><code class="language-shell">$ java -jar target/hello_world-1.0-SNAPSHOT.jar
Hello, world!
</code></pre>
<p>The native target works! Now continue to <a href="getting-started/develop/../distribute.html">Distribute</a> to learn how to run the WebAssembly target.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>No Java bindings to <a href="https://github.com/alphahorizonio/unisockets">unisockets</a> have been implemented yet.</p>
</div>
<h1><a class="header" href="#assemblyscript" id="assemblyscript">AssemblyScript</a></h1>
<h2><a class="header" href="#table-of-contents-6" id="table-of-contents-6">Table of Contents</a></h2>
<ul>
<li><a href="getting-started/develop/assemblyscript.html#language-support-status">Language Support Status</a></li>
<li><a href="getting-started/develop/assemblyscript.html#hello-world">Hello, world!</a>
<ul>
<li><a href="getting-started/develop/assemblyscript.html#package">Package</a></li>
<li><a href="getting-started/develop/assemblyscript.html#source-code">Source Code</a></li>
<li><a href="getting-started/develop/assemblyscript.html#make-configuration">Make Configuration</a></li>
<li><a href="getting-started/develop/assemblyscript.html#next-steps">Next Steps</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#language-support-status-6" id="language-support-status-6">Language Support Status</a></h2>
<table><thead><tr><th>Native</th><th>WebAssembly</th><th>Networking</th><th>Concurrency</th></tr></thead><tbody>
<tr><td>❌<sup class="footnote-reference"><a href="#1">1</a></sup></td><td>✅</td><td>❌<sup class="footnote-reference"><a href="#2">2</a></sup></td><td>❌<sup class="footnote-reference"><a href="#3">3</a></sup></td></tr>
</tbody></table>
<h2><a class="header" href="#hello-world-6" id="hello-world-6">Hello, world!</a></h2>
<p>Let's start by writing a hello world app in AssemblyScript. The full source code of this example is available on <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples/assemblyscript_hello_world">GitHub</a>.</p>
<h3><a class="header" href="#package" id="package">Package</a></h3>
<p>Create <code>package.json</code> with the following content:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;@alphahorizonio/assemblyscript_hello_world&quot;,
  &quot;version&quot;: &quot;0.0.1-alpha1&quot;,
  &quot;description&quot;: &quot;AssemblyScript webnetes Hello World example&quot;,
  &quot;main&quot;: &quot;main.ts&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;asbuild:untouched&quot;: &quot;asc main.ts --target debug&quot;,
    &quot;asbuild:optimized&quot;: &quot;asc main.ts --target release&quot;,
    &quot;asbuild&quot;: &quot;yarn asbuild:untouched &amp;&amp; yarn asbuild:optimized&quot;
  },
  &quot;author&quot;: &quot;Felicitas Pojtinger &lt;felicitas@pojtinger.com&gt;&quot;,
  &quot;license&quot;: &quot;AGPL-3.0&quot;,
  &quot;devDependencies&quot;: {
    &quot;assemblyscript&quot;: &quot;^0.17.13&quot;
  },
  &quot;dependencies&quot;: {
    &quot;as-wasi&quot;: &quot;^0.4.4&quot;
  }
}
</code></pre>
<p>Don't forget to change <code>@alphahorizonio/assemblyscript_hello_world</code> to a more appropriate package name.</p>
<p>Now, setup TypeScript by creating <code>tsconfig.json</code> with the following content:</p>
<pre><code class="language-json">{
  &quot;extends&quot;: &quot;assemblyscript/std/assembly.json&quot;,
  &quot;include&quot;: [&quot;./**/*.ts&quot;]
}
</code></pre>
<p>AssemblyScript requires another config file, so let's create <code>asconfig.json</code> with the following content:</p>
<pre><code class="language-json">{
  &quot;targets&quot;: {
    &quot;debug&quot;: {
      &quot;binaryFile&quot;: &quot;build/untouched.wasm&quot;,
      &quot;textFile&quot;: &quot;build/untouched.wat&quot;,
      &quot;sourceMap&quot;: true,
      &quot;debug&quot;: true
    },
    &quot;release&quot;: {
      &quot;binaryFile&quot;: &quot;build/optimized.wasm&quot;,
      &quot;textFile&quot;: &quot;build/optimized.wat&quot;,
      &quot;sourceMap&quot;: true,
      &quot;optimize&quot;: true
    }
  },
  &quot;options&quot;: {}
}
</code></pre>
<p>Finally, run the following to install the dependencies:</p>
<pre><code class="language-shell">$ yarn
</code></pre>
<h3><a class="header" href="#source-code-12" id="source-code-12">Source Code</a></h3>
<p>Create <code>main.ts</code> with the following content:</p>
<pre><code class="language-typescript">import { Console } from &quot;as-wasi&quot;;
import &quot;wasi&quot;;

Console.log(&quot;Hello, world!&quot;);
</code></pre>
<p>It prints <code>Hello, world!</code> to standard output.</p>
<h3><a class="header" href="#make-configuration-12" id="make-configuration-12">Make Configuration</a></h3>
<p>Create a <code>Makefile</code> with the following content:</p>
<pre><code class="language-Makefile">all:
	@docker run -v ${PWD}:/src:z node sh -c 'cd /src &amp;&amp; yarn &amp;&amp; yarn asbuild'
	@docker run -v ${PWD}:/src:z alphahorizonio/wasi-sdk sh -c 'cd /src &amp;&amp; wasm-opt --asyncify -O build/optimized.wasm -o build/optimized.wasm'

clean:
	@rm -rf build

seed: all
	@docker run -it -v ${PWD}/build:/build:z --entrypoint=/bin/sh schaurian/webtorrent-hybrid -c &quot;/usr/local/bin/webtorrent-hybrid seed /build/optimized.wasm&quot;
</code></pre>
<p>It provides three targets:</p>
<ul>
<li><code>make</code> builds the WebAssembly target</li>
<li><code>make clean</code> removes the built target</li>
<li><code>make seed</code> seeds the WebAssembly target, which will come in handy later.</li>
</ul>
<p>All of them use Docker, so there is no need to install any dependencies on the host.</p>
<h3><a class="header" href="#next-steps-13" id="next-steps-13">Next Steps</a></h3>
<p>Now continue to <a href="getting-started/develop/../distribute.html">Distribute</a> to learn how to run the WebAssembly target.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>AssemblyScript targets only WebAssembly.<br></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>No AssemblyScript bindings to <a href="https://github.com/alphahorizonio/unisockets">unisockets</a> have been implemented yet.<br></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>AssemblyScript does <a href="https://github.com/AssemblyScript/assemblyscript/issues/376">not yet support async/await</a>.<br></p>
</div>
<h1><a class="header" href="#more" id="more">More</a></h1>
<p>Webnetes can, in addition to the languages documented before, also run any further languages supported by the runtimes as <a href="getting-started/develop/../../architecture/compute.html">documented in Compute</a>. Even if your language doesn't support any of the ones specified there, adding support for another one is easy (just add your own handler to the <a href="https://github.com/alphahorizonio/webnetes/blob/main/lib/controllers/virtual-machine.ts#L12-L18">virtual machine</a>). If you wish to have another runtime officially supported, please open a new issue in the <a href="https://github.com/alphahorizonio/webnetes/issues">GitHub issue tracker</a> and we'll look into it.</p>
<h1><a class="header" href="#distribute" id="distribute">Distribute</a></h1>
<p>Now that you've got your app's build configuration up and running, you can start deploying your app to Webnetes. Doing so is a pretty simple process:</p>
<ol>
<li>Define your app's resources using a <code>stack.yaml</code> file</li>
<li>Create a cluster using <a href="https://webnetes.dev/">webnetesctl</a> or <a href="https://lite.webnetes.dev/">webnetesctl Lite</a></li>
<li>Invite nodes to your cluster</li>
<li>Deploy your app's resources to a desired target node</li>
<li>Open your app's terminal and interact with it!</li>
</ol>
<p>Let's get started!</p>
<h2><a class="header" href="#defining-the-resources" id="defining-the-resources">Defining the Resources</a></h2>
<p>The first step is to define your app's resources. Here you'll configure the app's capabilities, it's network configuration, runtime etc. It is quite similar to how <a href="https://kubernetes.io/">Kubernetes</a> handles it's resource definition; if you've used the latter before, you'll quickly get the hang of how to use Webnetes YAML.</p>
<p>You can find a pre-configured <code>stack.yaml</code> file for the examples in the corresponding source code; see <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples">alphahorizonio/webnetes/examples</a> for a list of all examples. To get a head start, you can use the <code>stack.yaml</code> of the example you've used. A typical <code>stack.yaml</code> (here of the C TCP Echo Server example) looks something like the following:</p>
<details>
	<summary>YAML Source</summary>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: Runtime
metadata:
  name: Generic WASI
  label: wasi_generic
spec: {}
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Capability
metadata:
  name: Creating a socket
  label: net_socket
spec: {}
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Capability
metadata:
  name: Sending over a socket
  label: net_send
spec: {}
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Capability
metadata:
  name: Receiving from a socket
  label: net_receive
spec: {}
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Capability
metadata:
  name: Binding an alias to a socket
  label: net_bind
spec: {}
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Capability
metadata:
  name: Listen on a socket
  label: net_listen
spec: {}
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Capability
metadata:
  name: Accept on a socket
  label: net_accept
spec: {}
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Processor
metadata:
  name: Felicitas's iPhone
  label: felicitass_iphone
spec:
  runtimes:
    - wasi_generic
  capabilities:
    - net_socket
    - net_send
    - net_receive
    - net_bind
    - net_listen
    - net_accept
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Signaler
metadata:
  name: Public unisockets Signaling Server
  label: unisockets_public
spec:
  urls:
    - wss://signaler.webnetes.dev
  retryAfter: 1000
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: StunServer
metadata:
  name: Google STUN Server
  label: google
spec:
  urls:
    - stun:stun.l.google.com:19302
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: StunServer
metadata:
  name: Twillio STUN Server
  label: twillio
spec:
  urls:
    - stun:global.stun.twilio.com:3478?transport=udp
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: TurnServer
metadata:
  name: Twillio TURN Server (UDP)
  label: twillio_udp
spec:
  urls:
    - turn:global.turn.twilio.com:3478?transport=tcp
  username: f4b4035eaa76f4a55de5f4351567653ee4ff6fa97b50b6b334fcc1be9c27212d
  credential: w1uxM55V9yVoqyVFjt+mxDBV0F87AUCemaYVQGxsPLw=
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: TurnServer
metadata:
  name: Twillio TURN Server (TCP)
  label: twillio_tcp
spec:
  urls:
    - turn:global.turn.twilio.com:3478?transport=tcp
  username: f4b4035eaa76f4a55de5f4351567653ee4ff6fa97b50b6b334fcc1be9c27212d
  credential: w1uxM55V9yVoqyVFjt+mxDBV0F87AUCemaYVQGxsPLw=
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: TurnServer
metadata:
  name: Twillio TURN Server Fallback (TCP)
  label: twillio_tcp_fallback
spec:
  urls:
    - turn:global.turn.twilio.com:443?transport=tcp
  username: f4b4035eaa76f4a55de5f4351567653ee4ff6fa97b50b6b334fcc1be9c27212d
  credential: w1uxM55V9yVoqyVFjt+mxDBV0F87AUCemaYVQGxsPLw=
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Network
metadata:
  name: Public unisockets network
  label: unisockets_public
spec:
  signaler: unisockets_public
  stunServers:
    - google
    - twillio
  turnServers:
    - twillio_udp
    - twillio_tcp
    - twillio_tcp_fallback
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: NetworkInterface
metadata:
  name: C Echo Network
  label: c_echo_network
spec:
  network: unisockets_public
  prefix: 127.19.0
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Tracker
metadata:
  name: OpenWebTorrent
  label: openwebtorrent
spec:
  urls:
    - wss://tracker.openwebtorrent.com
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Tracker
metadata:
  name: Fastcast
  label: fastcast
spec:
  urls:
    - wss://tracker.fastcast.nz
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Repository
metadata:
  name: Public WebTorrent
  label: webtorrent_public
spec:
  trackers:
    - openwebtorrent
    - fastcast
  stunServers:
    - google
    - twillio
  turnServers:
    - twillio_udp
    - twillio_tcp
    - twillio_tcp_fallback
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: File
metadata:
  name: C Echo Server Binary
  label: c_echo_server
spec:
  repository: webtorrent_public
  uri: d1eb90cb38bbffd1705f49e3e68a57d2c104b594
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Arguments
metadata:
  name: C Echo Server Configuration
  label: c_echo_server
spec:
  argv:
    - -l
    - 127.0.0.1
    - -p
    - 1234
---
apiVersion: schema.webnetes.dev/v1alpha1
kind: Workload
metadata:
  name: C Echo Server
  label: c_echo_server
spec:
  file: c_echo_server
  runtime: wasi_generic
  capabilities:
    - net_socket
    - net_send
    - net_receive
    - net_bind
    - net_listen
    - net_accept
  networkInterface: c_echo_network
  arguments: c_echo_server
  terminalLabel: c_echo_server
  terminalHostNodeId: localhost
</code></pre>
</details>
<p>You can find a full reference of the available resources in the <a href="getting-started/../reference/resources-yaml.html">Resources YAML Reference</a>.</p>
<h2><a class="header" href="#seeding-the-webassembly-binary" id="seeding-the-webassembly-binary">Seeding the WebAssembly Binary</a></h2>
<p>Next up, you have to make the WebAssembly binary available to Webnetes. This is done using <a href="https://webtorrent.io/">WebTorrent</a>, a BitTorrent implementation using WebRTC. For your convenience, a <code>seed</code> Make target has been added to the examples, but you can also seed using something like <a href="https://webtorrent.io/desktop/">WebTorrent Desktop</a>, <a href="https://instant.io/">instant.io</a>, <a href="https://webnetes.dev/">webnetesctl</a> or <a href="https://lite.webnetes.dev/">webnetesctl Lite</a>. For the following we'll use the <code>seed</code> Make target because it's the most convenient. Note that for Go there are two targets: <code>seed-go</code> and <code>seed-tinygo</code>. Consult the relevant <a href="getting-started/./develop/go.html">Develop section</a> for more information on what each target does.</p>
<p>Let's seed the WebAssembly binary; we'll use the <a href="getting-started/./develop/c.html#tcp-echo-server">C TCP Echo Server</a> as an example:</p>
<pre><code class="language-shell">$ make seed
Seeding: echo_server.wasm
Info hash: d1eb90cb38bbffd1705f49e3e68a57d2c104b594
Speed: 0 B/s Downloaded: 47 KB/47 KB Uploaded: 0 B
Running time: 10 seconds  Time remaining: N/A  Peers: 0/
</code></pre>
<p>Note the <code>Info hash</code> value; using it, for as long as you keep the terminal open, you can now fetch the WebAssembly binary from anywhere in the world, using for example <a href="https://instant.io/">instant.io</a>. The info hash changes whenever your binary changes, which means that it also serves as a kind of checksum.</p>
<p>Before we can start deployment, don't forget to replace the <code>uri</code> of the <code>File</code> resource in the <code>stack.yaml</code> above with the <code>Info hash</code> from the <code>make seed</code> command. It should look something like this (depending on the example you're using):</p>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: File
metadata:
  name: C Echo Server Binary
  label: c_echo_server
spec:
  repository: webtorrent_public
  uri: d1eb90cb38bbffd1705f49e3e68a57d2c104b594
</code></pre>
<h2><a class="header" href="#creating-a-cluster" id="creating-a-cluster">Creating a Cluster</a></h2>
<p>Let's create a cluster for our app. We'll use <a href="https://webnetes.dev/">webnetesctl</a> from now on, but feel free to use <a href="https://lite.webnetes.dev/">webnetesctl Lite</a> if you prefer something more lightweight.</p>
<p>First, open webnetesctl:</p>
<p><a href="https://webnetes.dev/"><img src="https://github.com/alphahorizonio/webnetesctl/raw/main/img/launch.png" width="240">
</a></p>
<p>You'll be presented with a screen like the following:</p>
<p><img src="getting-started/./img/start.png" alt="webnetesctl start screen" /></p>
<p>We now have to create a cluster using a cluster ID. We'll choose <code>69.42.8</code> in this example. Enter this value in the <code>New Cluster ID</code> field and click on <code>Create Cluster</code>. You should be greeted by the following:</p>
<p><img src="getting-started/./img/created.png" alt="webnetesctl created screen" /></p>
<p>You've now created a cluster! Next up is joining nodes. You can either scan the QR code with your phone or click on/share the link; nodes can join the cluster without any further configuration, after which they will see the following screen:</p>
<p><img src="getting-started/./img/joined.png" alt="webnetesctl joined screen" /></p>
<p>Once node have joined, a quick CPU &amp; Network benchmark runs and a short introduction is displayed. On the manager (where you got the link from), you can now go to the management interface by clicking on <code>Continue to Overview</code>. It looks something like this, depending on how many nodes you've added and whether the nodes have enabled location access by clicking on the location arrow in the center:</p>
<p><img src="getting-started/./img/overview.png" alt="webnetesctl overview screen" /></p>
<p>Before we'll continue deploying the resources, feel free to click around. By clicking a node you can get more information:</p>
<p><img src="getting-started/./img/inspector.png" alt="webnetesctl inspector" /></p>
<p>If you prefer a more traditional overview or are searching for something, the Explorer tab might be of use to you:</p>
<p><img src="getting-started/./img/explorer.png" alt="webnetesctl explorer" /></p>
<p>Feel free to try out the other screens before you continue!</p>
<h2><a class="header" href="#deploying-the-resources" id="deploying-the-resources">Deploying the Resources</a></h2>
<p>Let's deploy the resources. Doing so is simple; just click <code>+ Create</code> in the top menu and select <code>Resource</code>. Now, paste the contents of the <code>stack.yaml</code> file you've created above into the <code>Definition</code> editor; it's structure will be visualized to the right:</p>
<p><img src="getting-started/./img/create-resource.png" alt="webnetesctl create resource dialog" /></p>
<p>Next, let's adjust the server's network configuration by changing the <code>Arguments</code> resource to use an IP address in the within the cluster ID subnet we've created above (<code>69.42.8</code>):</p>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: Arguments
metadata:
  name: C Echo Server Configuration
  label: c_echo_server
spec:
  argv:
    - -l
    - 69.42.8.1
    - -p
    - 1234
</code></pre>
<p>This will set up the server to listen on <code>69.42.8.1:1234</code>.</p>
<p>Another thing you might want to change is the <code>terminalHostNodeId</code> of the <code>Workload</code> resource. This parameter specifies where to attach the terminal to; you probably want to attach it to your manager node for your convenience. To find your manager node's IP, minimize the dialog using the <code>_</code> button in the top right, and go to the <code>Config</code> tab:</p>
<p><img src="getting-started/./img/config.png" alt="webnetesctl config tab" /></p>
<p>Copy your IP, and open up the resource dialog again by clicking the tray in the bottom center. Now, replace the <code>Workload</code> resource's <code>terminalHostNodeId</code> key:</p>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: Workload
metadata:
  name: C Echo Server
  label: c_echo_server
spec:
  file: c_echo_server
  runtime: wasi_generic
  capabilities:
    - net_socket
    - net_send
    - net_receive
    - net_bind
    - net_listen
    - net_accept
  networkInterface: c_echo_network
  arguments: c_echo_server
  terminalLabel: c_echo_server
  terminalHostNodeId: 69.42.8.1
</code></pre>
<p>Now, let's select the node you want to deploy to:</p>
<p><img src="getting-started/./img/select-node.png" alt="webnetesctl node selection dialog" /></p>
<p>And click <code>+ Create resource</code>. This can take a while; feel free to minimize the dialog while the deployment is in process.</p>
<p>After the deployment has finished, and assuming you've set the <code>terminalHostNodeId</code> to the manager node's IP, a terminal should open up:</p>
<p><img src="getting-started/./img/terminal.png" alt="webnetesctl terminal" /></p>
<p>Awesome, you've just deployed your first app to webnetes! You could now repeat this process for the <a href="getting-started/./develop/c.html#tcp-echo-client">C TCP Echo Client</a> and test the full network, or continue to <a href="getting-started/./operate.html">Operate</a> for further operation resources.</p>
<h1><a class="header" href="#operate" id="operate">Operate</a></h1>
<p>After <a href="getting-started/./distribute.html">distributing</a>, we have now successfully deployed some resources to the cluster.</p>
<p>You can also check the resource graph of the target node to see the resource:</p>
<p><img src="getting-started/./img/target-node-resource-graph.png" alt="webnetesctl target node resource graph" /></p>
<p>If we minimize the terminal and click on the target node in the manager node, we can also see the newly created resources:</p>
<p><img src="getting-started/./img/target-node-on-globe.png" alt="webnetesctl resources on node in globe" /></p>
<p>The resources can also be found in the explorer:</p>
<p><img src="getting-started/./img/resources-in-explorer.png" alt="webnetesctl resource on node in explorer" /></p>
<p>Using the explorer or the overview, resources can now also be deleted.</p>
<h2><a class="header" href="#youre-done" id="youre-done">You're Done!</a></h2>
<p>🎉 That's it! You now know how to develop, distribute and operate your apps on Webnetes. There are many more features of Webnetes that we haven't touched on yet (the augmented reality resource graph, cluster statistics in the overview etc.), so feel free to play around with it!</p>
<h1><a class="header" href="#architecture" id="architecture">Architecture</a></h1>
<p>Webnetes is made up of four high-level, independent systems: a <a href="architecture/./compute.html">compute system</a>, a <a href="architecture/./networking.html">networking system</a>, a <a href="architecture/./storage.html">storage system</a> and finally a <a href="architecture/./management.html">management system</a>, which, once combined, form a <a href="architecture/../components/webnetes.html">Webnetes node</a>.</p>
<p>While the following is not exhaustive documentation, it should give you a quick overview of the systems; for a deeper understanding, please consult the linked source code documentation.</p>
<h1><a class="header" href="#compute" id="compute">Compute</a></h1>
<p>The Webnetes compute stack is build on <a href="https://en.wikipedia.org/wiki/WebAssembly">WebAssembly</a>, a byte-code format. The stack is configured using resources. In order to run WebAssembly (or WASM for short), a virtual machine is required. In the case of Webnetes, this component is called a runtime; the following are currently supported:</p>
<ul>
<li><a href="https://wasi.dev/">WASI</a> via <a href="https://github.com/wasmerio/wasmer-js">wasmer-js</a> — currently used to support C, C++, Rust, Zig, AssemblyScript and TinyGo (<code>wasm32-wasi</code> target)</li>
<li><a href="https://github.com/golang/go/blob/master/misc/wasm/wasm_exec.js">Go's wasm_exec</a> — currently used to support Go</li>
<li><a href="https://github.com/tinygo-org/tinygo/blob/release/targets/wasm_exec.js">TinyGo's wasm_exec</a> — currently used to support TinyGo (<code>wasm</code> target)</li>
<li><a href="http://teavm.org/">TeaVM</a> — currently used to support Java</li>
</ul>
<p>In Webnetes, a runtime also supports imports, which are enabled using capabilities. Imports are implemented using either the <a href="https://wasi.dev/">WebAssembly System Interface (WASI)</a> whenever supported by the runtime or a custom implementation which we call the JavaScript System Interface (JSSI).</p>
<p>Another feature is <code>stdin</code>/<code>stdout</code> redirection. Using the <a href="architecture/./networking.html">networking system</a>, Webnetes separates a workload from it's terminal, and enables attaching remote terminals to workloads anywhere in the cluster.</p>
<p>For more information on how to use the compute system, consult the <a href="architecture/../getting-started">getting started guide</a> or the <a href="architecture/../reference/resources-yaml.html">Resources YAML Reference</a>.</p>
<p>For more information on how the compute system works, consult the <a href="https://alphahorizonio.github.io/webnetes/classes/virtualmachine.html">virtual machine documentation</a>.</p>
<h1><a class="header" href="#networking" id="networking">Networking</a></h1>
<p>The Webnetes network stack is build on <a href="https://en.wikipedia.org/wiki/WebRTC">WebRTC</a>, a peer-to-peer real-time communication technology. This stack is used universally for both <a href="architecture/./management.html">management</a> and inter-workload communication and exposed using <a href="https://github.com/alphahorizonio/unisockets">unisockets</a>, a universal Berkeley sockets implementation for WebRTC. The stack is configured using resources.</p>
<p>For more information on how to use the networking system, consult the <a href="architecture/../getting-started">getting started guide</a> or the <a href="architecture/../reference/resources-yaml.html">Resources YAML Reference</a>.</p>
<p>For more information on how the networking system works, consult the <a href="https://alphahorizonio.github.io/unisockets/">unisockets Documentation</a> and in particular the <a href="https://alphahorizonio.github.io/unisockets/classes/transporter.html">unisockets Transporter documentation</a>.</p>
<h1><a class="header" href="#storage" id="storage">Storage</a></h1>
<p>The Webnetes storage/registry stack is build on <a href="https://en.wikipedia.org/wiki/WebTorrent">WebTorrent</a>, an implementation of the BitTorrent protocol based on WebRTC. It is used to make binaries available for workloads. The stack is configured using resources.</p>
<p>To support flexible/private deployments, Webnetes enables using multiple WebTorrent configurations using repositories. Binaries are referenced using an info hash or a magnet link, just like with BitTorrent.</p>
<p>For more information on how to use the storage system, consult the <a href="architecture/../getting-started">getting started guide</a> or the <a href="architecture/../reference/resources-yaml.html">Resources YAML Reference</a>.</p>
<p>For more information on how the storage system works, consult the <a href="https://alphahorizonio.github.io/webnetes/classes/filerepository.html">file repository documentation</a>.</p>
<h1><a class="header" href="#management" id="management">Management</a></h1>
<p>Webnetes is based on resources, which are documented in the <a href="architecture/../reference/resources-yaml.html">Resources YAML Reference</a>. The management system manages these resources across the cluster using a peer-to-peer client protocol based on the <a href="architecture/./networking.html">networking system</a>. This protocol is also used to transmit status messages and node information, such as benchmark scores and network performance.</p>
<p>For getting a deeper understanding on how the management system works, two pieces are important: the <a href="https://alphahorizonio.github.io/webnetes/classes/resources.html">resources pipe</a>, which handles resources on the local node and the <a href="https://alphahorizonio.github.io/webnetes/classes/peers.html">peer pipe</a>, which manages remote peer pipes and takes care of synchronization.</p>
<h1><a class="header" href="#components" id="components">Components</a></h1>
<p>The most high-level components of Webnetes are the <a href="components/./webnetes.html">node</a> and the <a href="components/./webnetesctl.html">app</a>. The former is used to build the app and can be embedded in any node or web app, the latter is a ready-to-use way of using Webnetes.</p>
<h1><a class="header" href="#node-webnetes" id="node-webnetes">Node (webnetes)</a></h1>
<p>The node is the embeddable version of Webnetes. It exposes the <a href="components/../architecture">four base systems</a> with an easy-to-use API and is used to power the <a href="components/./webnetesctl.html">app</a>. Using basic knowledge of JavaScript or TypeScript, it can be effortlessly embedded in any Node or web app if you wish to use any of Webnetes' features.</p>
<p>For more information, see the <a href="components/../reference/embedding-api.html">embedding API</a>.</p>
<h1><a class="header" href="#app-webnetesctl" id="app-webnetesctl">App (webnetesctl)</a></h1>
<h2><a class="header" href="#introduction-1" id="introduction-1">Introduction</a></h2>
<p>To interact with the <a href="components/./webnetes.html">node</a>, an app is used. It provides an easy-to-use interface to develop, distribute and operate apps on Webnetes. It should be noted that while webnetesctl is the primary app, you can also choose to use an alternative for a more lightweight experience or even build your own app without too much effort.</p>
<h2><a class="header" href="#implementations" id="implementations">Implementations</a></h2>
<h3><a class="header" href="#webnetesctl" id="webnetesctl">webnetesctl</a></h3>
<p><a href="https://webnetes.dev/"><img src="components/../getting-started/img/start.png" alt="webnetesctl start screen" /></a></p>
<p>Recommended for most users. Webnetesctl is built with React, Ant Design and the <a href="components/./webnetes.html">node</a>. For more information, check out the <a href="https://github.com/alphahorizonio/webnetesctl">source code</a>.</p>
<p><a href="https://webnetes.dev/"><img src="https://github.com/alphahorizonio/webnetesctl/raw/main/img/launch.png" width="240">
</a></p>
<h3><a class="header" href="#webnetesctl-lite" id="webnetesctl-lite">webnetesctl Lite</a></h3>
<p><a href="https://lite.webnetes.dev/"><img src="components/../getting-started/img/start-lite.png" alt="webnetesctl Lite start screen" /></a></p>
<p>For advanced users who prefer something more lightweight. Webnetesctl Lite is built with Vanilla JS; for more information, check out the <a href="https://github.com/alphahorizonio/webnetes/tree/main/app/webnetes_web">source code</a>.</p>
<p><a href="https://lite.webnetes.dev/"><img src="https://img.shields.io/badge/webnetesctl%20Lite-lite.webnetes.dev-blueviolet" alt="Lite" /></a></p>
<h1><a class="header" href="#bindings" id="bindings">Bindings</a></h1>
<p>If you want to support something that isn't part of your language's libraries or not supported by your runtime, you can polyfill it using bindings to Webnetes.</p>
<p>There are currently two bindings for this, in particular to support networking:</p>
<ul>
<li><a href="bindings/./unisockets.html">unisockets</a>, a universal Berkeley sockets implementation</li>
<li><a href="bindings/./tinynet.html">tinynet</a>, a net implementation for Go and TinyGo based on unisockets</li>
</ul>
<p>These bindings are enabled using capabilities.</p>
<h1><a class="header" href="#cc-networking-unisockets" id="cc-networking-unisockets">C/C++ Networking (unisockets)</a></h1>
<p>To support networking in C ABI compatible languages, such as C, C++, Go or TinyGo, unisockets is used. Consult the <a href="https://github.com/alphahorizonio/unisockets">unisockets Documentation</a> for more information.</p>
<h1><a class="header" href="#go-networking-tinynet" id="go-networking-tinynet">Go Networking (tinynet)</a></h1>
<p>To support networking in Go and TinyGo, you can either use <a href="bindings/./unisockets.html">unisockets</a> directly, or preferably tinynet, a <code>net</code> implementation for Go and TinyGo based on unisockets. Consult the <a href="https://github.com/alphahorizonio/tinynet">tinynet Documentation</a> for more information.</p>
<h1><a class="header" href="#reference" id="reference">Reference</a></h1>
<p>Here you can find reference information on the <a href="reference/./resources-yaml.html">Resources YAML</a> and the <a href="reference/./embedding-api.html">embedding API</a>.</p>
<h1><a class="header" href="#resources-yaml" id="resources-yaml">Resources YAML</a></h1>
<p>Webnetes is based on the concept of resources as the primary means of configuration. This is a listing of all available resources. Many examples of resource YAML usage can be found in the <code>stack.yaml</code> files in the <a href="https://github.com/alphahorizonio/webnetes/tree/main/examples">repository</a>.</p>
<p>Resources have a few common fields:</p>
<ul>
<li><code>apiVersion</code>: The API version, currently always <code>schema.webnetes.dev/v1alpha1</code></li>
<li><code>kind</code>: The resource type</li>
<li><code>metadata</code>: Contains a <code>label</code> (the node-unique identifier) and a <code>name</code> (the human-readable descriptor)</li>
<li><code>spec</code>: The resource-specific data</li>
</ul>
<p>This pattern is strongly influenced by <a href="https://kubernetes.io/">Kubernetes</a>.</p>
<h2><a class="header" href="#runtime" id="runtime">Runtime</a></h2>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: Runtime
metadata:
  name: Go JSSI
  label: jssi_go
spec: {}
</code></pre>
<p>A runtime adds support for a language, as described in <a href="reference/../architecture/compute.html">compute</a>. The label can be one of:</p>
<ul>
<li><code>wasi_generic</code>: For languages using WASI</li>
<li><code>wasi_tinygo</code>: Extended WASI for TinyGo</li>
<li><code>jssi_go</code>: For Go using JSSI</li>
<li><code>jssi_tinygo</code>: For TinyGo using JSSI</li>
<li><code>jssi_teavm</code>: For Java using JSSI</li>
</ul>
<h2><a class="header" href="#capability" id="capability">Capability</a></h2>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: Runtime
metadata:
  name: Go JSSI
  label: jssi_go
spec: {}
</code></pre>
<p>A capability enables imports, as described in <a href="reference/../architecture/compute.html">compute</a>. The label can be one of:</p>
<ul>
<li><code>net_socket</code>: Enables creating a socket</li>
<li><code>net_send</code>: Enables sending from a socket</li>
<li><code>net_receive</code>: Enables receiving from a socket</li>
<li><code>net_bind</code>: Enables binding a socket</li>
<li><code>net_listen</code>: Enables listening on a socket</li>
<li><code>net_accept</code>: Enables accepting on a socket</li>
<li><code>net_connect</code>: Enables connecting to a socket</li>
</ul>
<h2><a class="header" href="#processor" id="processor">Processor</a></h2>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: Processor
metadata:
  name: Felicitas's iPhone
  label: felicitass_iphone
spec:
  runtimes:
    - jssi_go
  capabilities:
    - net_socket
    - net_send
    - net_receive
    - net_bind
    - net_listen
    - net_accept
</code></pre>
<p>A processor defines a virtual node. It has the following fields:</p>
<ul>
<li><code>runtimes</code>: An array of <a href="reference/resources-yaml.html#runtime">runtime</a> labels</li>
<li><code>capabilties</code>: An array of <a href="reference/resources-yaml.html#capability">capability</a> labels</li>
</ul>
<h2><a class="header" href="#signaler" id="signaler">Signaler</a></h2>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: Signaler
metadata:
  name: Public unisockets Signaling Server
  label: unisockets_public
spec:
  urls:
    - wss://signaler.webnetes.dev
  retryAfter: 1000
</code></pre>
<p>A signaler signals connections as described in <a href="https://github.com/alphahorizonio/unisockets#components">unisockets</a>. It has the following fields:</p>
<ul>
<li><code>urls</code>: An array of <a href="https://github.com/alphahorizonio/unisockets#signaling-protocol">signaling server</a> URLs. Currently, only the first entry is respected.</li>
<li><code>retryAfter</code>: An interval in milliseconds after which to try to re-connect to the signaling servers</li>
</ul>
<h2><a class="header" href="#stun-server" id="stun-server">STUN Server</a></h2>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: StunServer
metadata:
  name: Google STUN Server
  label: google
spec:
  urls:
    - stun:stun.l.google.com:19302
</code></pre>
<p>A STUN Server creates peer-to-peer connections by hole-punching NATs. It has the following fields:</p>
<ul>
<li><code>urls</code>: An array of STUN server URLs.</li>
</ul>
<h2><a class="header" href="#turn-server" id="turn-server">TURN Server</a></h2>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: TurnServer
metadata:
  name: Twillio TURN Server (UDP)
  label: twillio_udp
spec:
  urls:
    - turn:global.turn.twilio.com:3478?transport=tcp
  username: myusername
  credential: mypassword
</code></pre>
<p>A TURN server relays messages when peer-to-peer connections are not possible. It has the following fields:</p>
<ul>
<li><code>urls</code>: An array of TURN server URLs</li>
<li><code>username</code>: The username to authenticate with when connecting to the TURN server</li>
<li><code>credential</code>: The credential to authenticate with when connecting to the TURN server</li>
</ul>
<h2><a class="header" href="#network" id="network">Network</a></h2>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: Network
metadata:
  name: Public unisockets network
  label: unisockets_public
spec:
  signaler: unisockets_public
  stunServers:
    - google
    - twillio
  turnServers:
    - twillio_udp
    - twillio_tcp
    - twillio_tcp_fallback
</code></pre>
<p>A network defines a global peer-to-peer overlay network. It has the following fields:</p>
<ul>
<li><code>signaler</code>: The label of a <a href="reference/resources-yaml.html#signaler">signaler</a> to use</li>
<li><code>stunServers</code>s: An array of <a href="reference/resources-yaml.html#stun-server">STUN server</a> labels</li>
<li><code>turnServers</code>s: An array of <a href="reference/resources-yaml.html#turn-server">TURN server</a> labels</li>
</ul>
<h2><a class="header" href="#network-interface" id="network-interface">Network Interface</a></h2>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: NetworkInterface
metadata:
  name: Go Echo Network
  label: go_echo_network
spec:
  network: unisockets_public
  prefix: 127.19.0
</code></pre>
<p>A network interface allow connecting to a <a href="reference/resources-yaml.html#network">network</a>'s subnet. It has the following fields:</p>
<ul>
<li><code>network</code>: The label of the <a href="reference/resources-yaml.html#network">network</a> in which the subnet resides. If it does not exist, it will be created.</li>
<li><code>prefix</code>: The first three octets of the subnet to create/join.</li>
</ul>
<h2><a class="header" href="#tracker" id="tracker">Tracker</a></h2>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: Tracker
metadata:
  name: OpenWebTorrent
  label: openwebtorrent
spec:
  urls:
    - wss://tracker.openwebtorrent.com
</code></pre>
<p>A tracker configures a WebTorrent tracker, which tracks the <a href="reference/resources-yaml.html#file">files</a> which are currently being seeded and by whom they are being seeded. It has the following fields:</p>
<ul>
<li><code>urls</code>: An array of tracker server URLs. Currently, only the first entry is respected.</li>
</ul>
<h2><a class="header" href="#repository" id="repository">Repository</a></h2>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: Repository
metadata:
  name: Public WebTorrent
  label: webtorrent_public
spec:
  trackers:
    - openwebtorrent
    - fastcast
  stunServers:
    - google
    - twillio
  turnServers:
    - twillio_udp
    - twillio_tcp
    - twillio_tcp_fallback
</code></pre>
<p>A repository enables seeding &amp; adding <a href="reference/resources-yaml.html#file">file</a>s. It has the following fields:</p>
<ul>
<li><code>trackers</code>: An array of <a href="reference/resources-yaml.html#tracker">tracker</a> labels</li>
<li><code>stunServers</code>s: An array of <a href="reference/resources-yaml.html#stun-server">STUN server</a> labels</li>
<li><code>turnServers</code>s: An array of <a href="reference/resources-yaml.html#turn-server">TURN server</a> labels</li>
</ul>
<h2><a class="header" href="#file" id="file">File</a></h2>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: File
metadata:
  name: Go Echo Server Binary
  label: go_echo_server
spec:
  repository: webtorrent_public
  uri: 83db73bb4b044a05df306330e421b2e3d38849e4
</code></pre>
<p>A file references a file seeded using WebTorrent in a <a href="reference/resources-yaml.html#repository">repository</a>. It has the following fields:</p>
<ul>
<li><code>repository</code>: The <a href="reference/resources-yaml.html#repository">repository</a> to which the file should be added</li>
<li><code>uri</code>: The magnet link or info hash of the file to add</li>
</ul>
<h2><a class="header" href="#arguments" id="arguments">Arguments</a></h2>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: Arguments
metadata:
  name: Go Echo Server Configuration
  label: go_echo_server
spec:
  argv:
    - -laddr
    - 127.0.8.1:4206
</code></pre>
<p>A arguments resource supplies the command line arguments for a <a href="reference/resources-yaml.html#workload">workload</a> and thus allows configuring your app without requiring interactivity and without re-compiling the binary. It has the following fields:</p>
<ul>
<li><code>argv</code>: An array of command-line arguments to pass to the workload</li>
</ul>
<h2><a class="header" href="#workload" id="workload">Workload</a></h2>
<pre><code class="language-yaml">apiVersion: schema.webnetes.dev/v1alpha1
kind: Workload
metadata:
  name: Go Echo Server
  label: go_echo_server
spec:
  file: go_echo_server
  runtime: jssi_go
  capabilities:
    - net_socket
    - net_send
    - net_receive
    - net_bind
    - net_listen
    - net_accept
  networkInterface: go_echo_network
  arguments: go_echo_server
  terminalLabel: go_echo_server
  terminalHostNodeId: localhost
</code></pre>
<p>A workload configures an app's resources. It has the following fields:</p>
<ul>
<li><code>file</code>: The label of the <a href="reference/resources-yaml.html#file">file resource</a> to use for the workload (the WASM binary)</li>
<li><code>runtime</code>: The label of the <a href="reference/resources-yaml.html#runtime">runtime</a> to use for running the workload</li>
<li><code>capabilities</code>s: An array of <a href="reference/resources-yaml.html#capability">capability</a> labels. These capabilities must also exist on the processor you are deploying to (the node).</li>
<li><code>networkInterface</code>: The label of the <a href="reference/resources-yaml.html#network-interface">network interface</a> to attach</li>
<li><code>arguments</code>: The label of the <a href="reference/resources-yaml.html#network-interface">network interface</a> to attach</li>
<li><code>terminalLabel</code>: Unique label by which to identify the <a href="reference/resources-yaml.html#workload">workload</a>'s terminal</li>
<li><code>terminalHostNodeId</code>: The node ID to attach the terminal to. <code>localhost</code> references the node onto which the workload is being deployed.</li>
</ul>
<h1><a class="header" href="#embedding-api" id="embedding-api">Embedding API</a></h1>
<p>Embedding the <a href="reference/../components/webnetes.html">node</a> is easy and <a href="https://alphahorizonio.github.io/webnetes/classes/node.html">API documentation is available</a>.</p>
<h2><a class="header" href="#getting-the-library" id="getting-the-library">Getting the Library</a></h2>
<p>Webnetes is available on npm. You can add it to your app like so:</p>
<pre><code class="language-shell">yarn add @alphahorizonio/webnetes
# Or with npm
npm i -s @alphahorizonio/webnetes
</code></pre>
<p>If you don't have a bundler available, we also provide a ready-to-use precompiled script which you can include like so:</p>
<pre><code class="language-html">&lt;script src=&quot;https://unpkg.com/@alphahorizonio/webnetes@0.1.2/dist/webLibIIFE/index.iife.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>If you're using the script, the node will be available as <code>window.WebnetesNode</code>. If you used the NPM package, you can import it like so:</p>
<pre><code class="language-typescript">import { Node } from &quot;@alphahorizonio/webnetes&quot;;
</code></pre>
<h2><a class="header" href="#using-the-library-in-the-browser" id="using-the-library-in-the-browser">Using the Library in the Browser</a></h2>
<p>This should enable you to create a minimal node in the browser:</p>
<pre><code class="language-typescript">const node = new Node(
  async (nodeId, resource) =&gt; {
    console.console.log(&quot;Created resource&quot;, nodeId, resource);
  },
  async (nodeId, resource) =&gt; {
    console.console.log(&quot;Deleted resource&quot;, nodeId, resource);

    if (resource.kind === &quot;workload&quot;) window.location.reload();
  },
  async (frame) =&gt; {
    console.console.log(&quot;Rejected resource&quot;, frame);
  },
  async (id) =&gt; {
    console.console.log(&quot;Management node acknowledged&quot;, id);
  },
  async (id) =&gt; {
    console.console.log(&quot;Management node joined&quot;, id);
  },
  async (id) =&gt; {
    console.console.log(&quot;Management node left&quot;, id);
  },
  async (metadata, spec, id) =&gt; {
    console.console.log(&quot;Resource node acknowledged&quot;, metadata, spec, id);
  },
  async (metadata, spec: INetworkInterfaceSpec, id) =&gt; {
    console.console.log(&quot;Resource node joined&quot;, metadata, spec, id);
  },
  async (metadata, spec, id) =&gt; {
    console.console.log(&quot;Resource node left&quot;, metadata, spec, id);
  },
  async (onStdin: (key: string) =&gt; Promise&lt;void&gt;, id) =&gt; {
    // TODO: Implement terminal creation
  },
  async (id, msg) =&gt; {
    // TODO: Implement terminal write
  },
  async (id) =&gt; {
    // TODO: Implement terminal deletion
  },
  (id) =&gt; {
    const rawInput = prompt(`Please enter standard input for ${id}\n`);

    if (rawInput) return new TextEncoder().encode(rawInput);

    return null;
  }
);
</code></pre>
<p>Now, implement the <code>TODO</code>s and <code>open</code> the node using the configuration resources. You can find the full source code <a href="https://github.com/alphahorizonio/webnetes/tree/main/app/webnetes_web">in the repository</a>. Consult the <a href="https://alphahorizonio.github.io/webnetes/classes/node.html">API documentation</a> for further resources.</p>
<h2><a class="header" href="#using-the-library-in-nodejs" id="using-the-library-in-nodejs">Using the Library in Node.js</a></h2>
<p>Webnetes also has Node.js support. This should enable you to create a minimal node in this context:</p>
<pre><code class="language-typescript">const node = new Node(
  async (nodeId, resource) =&gt; {
    console.log(&quot;Created resource&quot;, nodeId, resource);
  },
  async (nodeId, resource) =&gt; {
    console.log(&quot;Deleted resource&quot;, nodeId, resource);

    if (resource.kind === &quot;workload&quot;) {
      spawn(process.execPath, process.argv.slice(1), {
        cwd: process.cwd(),
        detached: true,
        env: process.env,
        stdio: &quot;inherit&quot;,
      }).unref();

      process.exit(0);
    }
  },
  async (frame) =&gt; {
    console.log(&quot;Rejected resource&quot;, frame);
  },
  async (id) =&gt; {
    console.log(&quot;Management node acknowledged&quot;, id);
  },
  async (id) =&gt; {
    console.log(&quot;Management node joined&quot;, id);
  },
  async (id) =&gt; {
    console.log(&quot;Management node left&quot;, id);
  },
  async (metadata, spec, id) =&gt; {
    console.log(&quot;Resource node acknowledged&quot;, metadata, spec, id);
  },
  async (metadata, spec: INetworkInterfaceSpec, id) =&gt; {
    console.log(&quot;Resource node joined&quot;, metadata, spec, id);
  },
  async (metadata, spec, id) =&gt; {
    console.log(&quot;Resource node left&quot;, metadata, spec, id);
  },
  async (onStdin: (key: string) =&gt; Promise&lt;void&gt;, id) =&gt; {
    console.log(&quot;Creating terminal (STDOUT only)&quot;, id);
  },
  async (id, msg) =&gt; {
    console.log(&quot;Writing to terminal (STDOUT only)&quot;, id, msg);
  },
  async (id) =&gt; {
    console.log(&quot;Deleting terminal&quot;, id);
  },
  (id) =&gt; {
    console.error(&quot;STDIN is not supported on node&quot;);

    process.exit(1);
  }
);
</code></pre>
<p>Now, <code>open</code> the node using the configuration resources. You can find the full source code <a href="https://github.com/alphahorizonio/webnetes/tree/main/app/webnetes_node">in the repository</a>. Consult the <a href="https://alphahorizonio.github.io/webnetes/classes/node.html">API documentation</a> for further resources.</p>
<h1><a class="header" href="#contributing" id="contributing">Contributing</a></h1>
<p>Webnetes is being developed as free/libre and open source sofware in the Alpha Horizon organization on <a href="https://github.com/alphahorizonio">GitHub</a>. We appreciate contributions, and there is no need to sign a CLA!</p>
<h2><a class="header" href="#chat" id="chat">Chat</a></h2>
<ul>
<li><strong>Are you a user and have questions?</strong> Join <a href="https://matrix.to/#/#webnetes-contributors:matrix.org?via=matrix.org">Webnetes Users on Matrix</a> and we'll help you.</li>
<li><strong>Want to contribute?</strong> Join <a href="https://matrix.to/#/#webnetes-contributors:matrix.org?via=matrix.org">Webnetes Contributors on Matrix</a> and chat with us!</li>
</ul>
<h2><a class="header" href="#code-of-conduct" id="code-of-conduct">Code of Conduct</a></h2>
<p>Please follow our <a href="https://github.com/alphahorizonio/webnetes-book/blob/main/CODE_OF_CONDUCT.md">Code of Conduct</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
